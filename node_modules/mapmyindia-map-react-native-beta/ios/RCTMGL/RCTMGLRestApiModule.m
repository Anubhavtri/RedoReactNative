//
//  RCTMGLRestApiModule.m
//  mapmyindia-map-react-native
//
//  Created by ceinfo on 11/05/21.
//

#import <Foundation/Foundation.h>
#import "RCTMGLRestApiModule.h"
#import <CoreLocation/CoreLocation.h>
#import <MapmyIndiaAPIKit/MapmyIndiaAPIKit.h>
@import MapmyIndiaDirections;
#import "NSObject+BWJSONMatcher.h"
#import <MapKit/MKGeometry.h>

@implementation RCTMGLRestApiModule

RCT_EXPORT_MODULE();



//exporting constants to js side
- (NSDictionary *)constantsToExport
{
    
    
    NSDictionary * autosuggestConstants = @{
        @"POD_CITY": MMIPodTypeIdentifierCity,
        @"POD_DISTRICT": MMIPodTypeIdentifierDistrict,
        @"POD_LOCALITY":MMIPodTypeIdentifierLocality,
        @"POD_STATE": MMIPodTypeIdentifierState,
        @"POD_SUB_DISTRICT": MMIPodTypeIdentifierSubdistrict,
        @"POD_SUB_LOCALITY": MMIPodTypeIdentifierSublocality,
        @"POD_SUB_SUB_LOCALITY": MMIPodTypeIdentifierSubSubLocality,
        @"POD_VILLAGE": MMIPodTypeIdentifierVillage,
    };
    
    NSDictionary * geoCodeConstants = @{
        //Not avaialble for IOS
//        @"BIAS_DEFAULT": MMIPodTypeIdentifierCity,
//        @"BIAS_RURAL": MMIPodTypeIdentifierDistrict,
//        @"BIAS_URBAN":MMIPodTypeIdentifierLocality,
//
//        @"POD_CITY": MMIPodTypeIdentifierState,
//        @"POD_DISTRICT": MMIPodTypeIdentifierSubdistrict,
//        @"POD_HOUSE_NAME": MMIPodTypeIdentifierSublocality,
//        @"POD_HOUSE_NUMBER": MMIPodTypeIdentifierSubSubLocality,
//        @"POD_LOCALITY": MMIPodTypeIdentifierVillage,
//        @"POD_PINCODE": MMIPodTypeIdentifierVillage,
//        @"POD_POINT_OF_INTEREST": MMIPodTypeIdentifierVillage,
//        @"POD_STATE": MMIPodTypeIdentifierVillage,
//        @"POD_STREET": MMIPodTypeIdentifierVillage,
//        @"POD_SUB_DISTRICT": MMIPodTypeIdentifierVillage,
//        @"POD_SUB_LOCALITY": MMIPodTypeIdentifierVillage,
//        @"POD_SUB_SUB_LOCALITY": MMIPodTypeIdentifierVillage,
//        @"POD_VILLAGE": MMIPodTypeIdentifierVillage,
    };
    
    NSDictionary * nearbyConstants = @{
        @"DISTANCE_ASCENDING": MMISortByOrderTypeAscending,
        @"DISTANCE_DESCENDING": MMISortByOrderTypeAscending,
        
        //TODO: NEED TO CHECK
//        @"NAME_ASCENDING":MMISortByOrderTypeAscending,
//        @"NAME_DESCENDING": MMISortByOrderTypeDescending,
        
        @"DISTANCE": MMISearchByTypeDistance,
        @"IMPORTANCE": MMISearchByTypeImportance,
       
    };
    
    NSDictionary * directionConstants = @{
        //TODO: NEED TO CHECK
        @"EXCLUDE_TUNNEL": MMIPodTypeIdentifierCity,
        @"EXCLUDE_RESTRICTED": MMIPodTypeIdentifierDistrict,
        @"EXCLUDE_MOTORWAY":MMIPodTypeIdentifierLocality,
        @"EXCLUDE_FERRY": MMIPodTypeIdentifierState,
        @"EXCLUDE_TOLL": MMIPodTypeIdentifierSubdistrict,
        
        //TODO: NEED TO CHECK
        @"ANNOTATION_SPEED": @"speed",
        @"ANNOTATION_NODES": @"nodes",
        @"ANNOTATION_MAXSPEED": @"maxSpeed",
        @"ANNOTATION_DURATION": @"duration",
        @"ANNOTATION_DISTANCE": MMIPodTypeIdentifierVillage,
        @"ANNOTATION_BASE_DURATION": MMIPodTypeIdentifierVillage,
        @"ANNOTATION_CONGESTION": @"congestion",
        @"ANNOTATION_SPEED_LIMIT": @"speedLimit",


        @"OVERVIEW_FALSE": [NSNumber numberWithLong:MBRouteShapeResolutionNone],
        @"OVERVIEW_SIMPLIFIED":[NSNumber numberWithLong: MBRouteShapeResolutionLow],
        @"OVERVIEW_FULL": [NSNumber numberWithLong:MBRouteShapeResolutionFull],


        @"PROFILE_WALKING": @"walking" ,
        @"PROFILE_TRUCKING": @"trucking",
        @"PROFILE_BIKING": @"biking",
        @"PROFILE_DRIVING": @"driving",


        @"RESOURCE_ROUTE_TRAFFIC": @"route_traffic",
        @"RESOURCE_ROUTE": @"route_adv",
        @"RESOURCE_ROUTE_ETA": @"route_eta",
        @"RESOURCE_DISTANCE": MapmyIndiaDistanceMatrixResourceIdentifierDefault,
        @"RESOURCE_DISTANCE_ETA": MapmyIndiaDistanceMatrixResourceIdentifierEta,
        @"RESOURCE_DISTANCE_TRAFFIC": MapmyIndiaDistanceMatrixResourceIdentifierTraffic,


        @"GEOMETRY_POLYLINE": @"polyline",
        @"GEOMETRY_POLYLINE6": @"polyline6",


        @"IMPERIAL": [NSNumber numberWithUnsignedLong:MBMeasurementSystemImperial],
        @"METRIC": [NSNumber numberWithUnsignedLong:MBMeasurementSystemMetric],

        //TODO: NEED TO CHECK
        @"SOURCE_ANY": MMIPodTypeIdentifierVillage,
        @"SOURCE_FIRST": MMIPodTypeIdentifierVillage,

        //TODO: NEED TO CHECK
        @"APPROACH_CURB": MMIPodTypeIdentifierVillage,
        @"APPROACH_UNRESTRICTED": MMIPodTypeIdentifierVillage,

        //TODO: NEED TO CHECK
        @"DESTINATION_ANY": MMIPodTypeIdentifierVillage,
        @"DESTINATION_LAST": MMIPodTypeIdentifierVillage,
    };

      NSDictionary * poiConstants = @{
        @"GEOMETRY_BASE64": MMIPolylineGeometryTypeBase64,
        @"GEOMETRY_POLYLINE5": MMIPolylineGeometryTypeBase64,
        @"GEOMETRY_POLYLINE6": MMIPolylineGeometryTypeBase64,
    };

    NSDictionary * sessionConstants = @{
      @"SESSION_TYPE_GLOBAL": @0,
      @"SESSION_TYPE_NAVIGATION": @1,
  };

 return @{
     @"AutoSuggestCriteria":autosuggestConstants,
     @"GeoCodingCriteria":geoCodeConstants,
     @"NearbyCriteria":nearbyConstants,
     @"DirectionsCriteria":directionConstants,
     @"POICriteria":poiConstants,
     @"SessionCriteria": sessionConstants,
 };
}


//required for exporting constants
+(BOOL)requiresMainQueueSetup
{
    return YES;
}

NSString * const REQUIRED_CODE = @"REQUIRED PARAMETER";
//Reverse GeoCoding API
RCT_EXPORT_METHOD(reverseGeocode:(nonnull NSDictionary  *) map resolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)
{

    NSNumber *latitude;
    if ([map objectForKey:@"latitude"] != nil){
        latitude = [map objectForKey:@"latitude"];
    }else{
        reject(REQUIRED_CODE,@"Please provide latitude parameter",nil);
       // failureCallback(@[@"Please provide latitude parameter"]);
    }

    NSNumber *longitude;
    if ([map objectForKey:@"longitude"] != nil){
        longitude = [map objectForKey:@"longitude"];
    }else{
        reject(REQUIRED_CODE,@"Please provide longitude parameter",nil);
       // failureCallback(@[@"Please provide longitude parameter"]);
    }

    if (latitude<0||longitude<0) {
        reject(REQUIRED_CODE,@"Please provide valid location",nil);
        //failureCallback(@[@"Please provide valid location"]);
        return;
    }


    MapmyIndiaReverseGeocodeOptions *revOptions= [[MapmyIndiaReverseGeocodeOptions alloc]  initWithLocation:[[CLLocation alloc] initWithLatitude:[latitude doubleValue] longitude:[longitude doubleValue]]   withRegion:MMIRegionTypeIdentifierIndia];



    MapmyIndiaReverseGeocodeManager * reverseGeocodeManager = [MapmyIndiaReverseGeocodeManager sharedManager];

    [reverseGeocodeManager reverseGeocodeWithOptions:revOptions completionHandler:^(NSArray<MapmyIndiaGeocodedPlacemark *> * _Nullable placemarks, NSString * _Nullable attribution, NSError * _Nullable error) {
             if (error) {
                        NSLog(@"%@", error);
                 reject(@"0",error.description,nil);
                 //failureCallback(@[error.description]);
                } else if (placemarks.count > 0) {

                    // convert data model to json string
                    NSString *jsonString = [self reverseGeoCodeResponse:placemarks];
                    resolve(jsonString);
                   // successCallback(@[@200,jsonString]);

                } else {
                    NSDictionary *dict = @{@"results":@[],@"responseCode":@200};
                    resolve([dict toJSONString]);
                   // successCallback(@[@200,dict]);
                }
        }];

}

//GeoCoding API
RCT_EXPORT_METHOD(geocode:(nonnull NSDictionary  *) map resolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)
{
    NSString *address;

    if ([map objectForKey:@"address"] != nil){
        address = [map objectForKey:@"address"];
    }else{
        reject(REQUIRED_CODE,@"Please provide address parameter",nil);
       // failureCallback(@[@"Please provide address parameter"]);
        return;
    }

    MapmyIndiaAtlasGeocodeManager * atlasGeocodeManager = [MapmyIndiaAtlasGeocodeManager sharedManager];
    MapmyIndiaAtlasGeocodeOptions *atlasGeocodeOptions = [[MapmyIndiaAtlasGeocodeOptions alloc] initWithQuery: address withRegion:MMIRegionTypeIdentifierIndia];
    [self addGeocodeOptions:map atlasGeocodeOptions:atlasGeocodeOptions];


[atlasGeocodeManager getGeocodeResultsWithOptions:atlasGeocodeOptions completionHandler:^(MapmyIndiaAtlasGeocodeAPIResponse * _Nullable response, NSError * _Nullable error) {
        if (error) {
            reject(@"0",error.description,nil);
            //failureCallback(@[error.description]);
        } else if (response!= nil && response.placemarks.count > 0) {
            NSString *jsonString = [self geoCodeResponse:response];
            resolve(jsonString);
           // successCallback(@[@200,jsonString]);
            return;
        } else {
            NSDictionary *dict = @{@"results":@[],@"responseCode":@200};
            resolve([dict toJSONString]);
           // successCallback(@[@200,dict]);
        }
    }];

}


//AutoSuggest API
RCT_EXPORT_METHOD(autoSuggest:(nonnull NSDictionary  *) map resolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)
{

    NSString *query;

    if ([map objectForKey:@"query"] != nil){
        query = [map objectForKey:@"query"];
    }else{
        reject(REQUIRED_CODE,@"Please provide query parameter",nil);
        //failureCallback(@[@"Please provide query parameter"]);
        return;
    }



    MapmyIndiaAutoSuggestManager * autoSuggestManager = [MapmyIndiaAutoSuggestManager sharedManager];

    MapmyIndiaAutoSearchAtlasOptions * autoSuggestOptions =[[MapmyIndiaAutoSearchAtlasOptions alloc] initWithQuery:query withRegion:MMIRegionTypeIdentifierIndia];

    [self addAutoSuggestOptions:map autoSuggesstOptions:autoSuggestOptions];

    [autoSuggestManager getAutoSuggestionsWithOptions:autoSuggestOptions completionHandler:
     ^(NSArray<MapmyIndiaAtlasSuggestion *> * _Nullable suggestions, NSError * _Nullable error) {
                                                    if (error) {
                                                NSLog(@"%@", error);
                                reject(@"0",error.description,nil);
                                           // failureCallback(@[error.description]);
                                        } else if (suggestions.count > 0) {
                                            NSString *jsonString = [self autoSuggestResponse:suggestions];
                                            resolve(jsonString);
                                          //  successCallback(@[@200,jsonString]);
                                            return;

                                        } else {
                                            NSDictionary *dict = @{@"suggestedLocations":@[]};
                                            //successCallback(@[@200,dict]);
                                            resolve([dict toJSONString]);
                                        }}];


}


//Nearby Api
RCT_EXPORT_METHOD(nearby:(nonnull NSDictionary  *) map resolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)
{

    NSString *keyword;

    if ([map objectForKey:@"keyword"] != nil){
        keyword = [map objectForKey:@"keyword"];
    }else{
        reject(REQUIRED_CODE,@"Please provide keyword parameter",nil);
        //failureCallback(@[@"Please provide keyword parameter"]);
        return;
    }
    NSString *refLocation;
    if ([map objectForKey:@"location"] != nil){
        refLocation = [map objectForKey:@"location"];
    }else{
        reject(REQUIRED_CODE,@"Please provide location parameter",nil);
        //failureCallback(@[@"Please provide location parameter"]);
        return;
    }


    MapmyIndiaNearByManager * nearByManager = [MapmyIndiaNearByManager sharedManager];


    MapmyIndiaNearbyAtlasOptions *nearByOptions = [[MapmyIndiaNearbyAtlasOptions alloc] initWithQuery:keyword location:refLocation withRegion:MMIRegionTypeIdentifierIndia];
    [self addNearbyOptions:map nearbyOptions:nearByOptions];

        [nearByManager getNearBySuggestionsWithOptions:nearByOptions completionHandler:^(MapmyIndiaNearbyResult * _Nullable
             result, NSError * _Nullable error) {
                if (error) {
                        NSLog(@"%@", error);
                    reject(@"0",error.description,nil);
                    //failureCallback(@[error.description]);
                    } else if (result.suggestions.count > 0) {
                              NSString *jsonString = [self nearByResponse:result];
                        resolve(jsonString);
                              //successCallback(@[@200,jsonString]);
                              return;

                    } else {
                        NSDictionary *dict = @{@"suggestedLocations":@[],@"pageInfo":@[]};
                        resolve([dict toJSONString]);
                        //successCallback(@[@200,dict]);
                    }
                }];


}

//distance matrix api
RCT_EXPORT_METHOD(distance:(nonnull NSDictionary *) map resolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)
{
    NSArray<NSString *> * coordinates;

    if ([map objectForKey:@"coordinates"] != nil){
        coordinates = [map objectForKey:@"coordinates"];
        if (coordinates.count<2) {
            reject(REQUIRED_CODE,@"Please provide atleast two coordinates",nil);
            //failureCallback(@[@"Please provide atleast two coordinates"]);
            return;
        }
    }else{
        reject(REQUIRED_CODE,@"Please provide coordinates parameter",nil);
        //failureCallback(@[@"Please provide coordinates parameter"]);
        return;
    }

    MapmyIndiaDrivingDistanceMatrixManager *distanceMatrixManager = [MapmyIndiaDrivingDistanceMatrixManager sharedManager];

    MapmyIndiaDrivingDistanceMatrixOptions *distanceMatrixOptions = [[MapmyIndiaDrivingDistanceMatrixOptions alloc] initWithLocations:coordinates withRegion:MMIRegionTypeIdentifierIndia];

    [self addDistanceMatrixOptions:map distanceMatrixOptions:distanceMatrixOptions];



        [distanceMatrixManager getResultWithOptions:distanceMatrixOptions completionHandler:^(MapmyIndiaDrivingDistanceMatrixResponse * _Nullable result, NSError * _Nullable error) {
            if (error) {
                NSLog(@"%@", error);
                reject(@"0",error.description,nil);
               // failureCallback(@[error.description]);
            } else if (result != nil  && result.results != nil) {
                NSString *jsonString = [self distanceResponse:result];
                resolve(jsonString);
               // successCallback(@[@200,jsonString]);
                return;
            } else {
                NSLog(@"No results");
                NSDictionary *resultDict = @{@"results":@{},@"responseCode":result.responseCode,@"version":result.version};
                resolve([resultDict toJSONString]);
               // successCallback(@[@200,[resultDict toJSONString]]);
                return;
            }
        }];
}


//place Detail api
RCT_EXPORT_METHOD(placeDetail:(nonnull NSDictionary *) map resolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)
{
    if ([map objectForKey:@"eLoc"] == nil){
        reject(REQUIRED_CODE,@"Please provide eLoc parameter",nil);
        //failureCallback(@[@"Please provide eLoc parameter"]);
        return;
    }

    NSString *eLoc=[map objectForKey:@"eLoc"];
    MapmyIndiaPlaceDetailManager *placeDetailManger = [MapmyIndiaPlaceDetailManager sharedManager];

    MapmyIndiaPlaceDetailOptions *placeDetailsOptions = [[MapmyIndiaPlaceDetailOptions alloc] initWithELoc:eLoc withRegion:MMIRegionTypeIdentifierIndia];

    [placeDetailManger getResultsWithOptions:placeDetailsOptions completionHandler:^(MapmyIndiaPlaceDetail * _Nullable result, NSError * _Nullable error){
        if (error) {
            NSLog(@"%@", error);
            reject(@"0",error.description,nil);
            //failureCallback(@[error.description]);
        } else if (result!=nil) {
            NSString *jsonString = [self placeDetailResponse:result];
           // successCallback(@[@200,jsonString]);
            resolve(jsonString);
            return;
        }

    }];
}


//place Detail Legacy api
RCT_EXPORT_METHOD(placeDetailLegacy:(nonnull NSDictionary *) map resolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)
{
    if ([map objectForKey:@"eLoc"] == nil){
        reject(REQUIRED_CODE,@"Please provide eLoc parameter",nil);
        //failureCallback(@[@"Please provide eLoc parameter"]);
        return;
    }

    NSString *eLoc=[map objectForKey:@"eLoc"];
    MapmyIndiaPlaceDetailLegacyManager * placeDetailManager =[MapmyIndiaPlaceDetailLegacyManager sharedManager];

    MapmyIndiaPlaceDetailLegacyOptions *placeDetailsOptions = [[MapmyIndiaPlaceDetailLegacyOptions alloc] initWithPlaceId:eLoc withRegion:MMIRegionTypeIdentifierIndia];

    [placeDetailManager getPlaceDetailWithOptions:placeDetailsOptions completionHandler:^(NSArray<MapmyIndiaGeocodedPlacemark *> * _Nullable placemarks, NSString * _Nullable attribution, NSError * _Nullable error) {
                                        if (error) {
                                            NSLog(@"%@", error);
                                            reject(@"0",error.description,nil);
                                            //failureCallback(@[error.description]);
                                            } else if (placemarks.count > 0) {
                                                NSString *jsonString = [self placeDetailLegacyResponse:placemarks];
                                                resolve(jsonString);
                                               // successCallback(@[@200,jsonString]);
                                                return;
                                            } else {
                                                NSDictionary *resultDict = @{@"results":@[]};
                                                resolve([resultDict toJSONString]);
                                                return ;
                                                }
                                        }];
}




//POIAlongRoute api
RCT_EXPORT_METHOD(POIAlongRoute:(nonnull NSDictionary *) map resolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)
{

    NSString *routePath;
    NSString *category;

    if ([map objectForKey:@"category"] == nil){
        reject(REQUIRED_CODE,@"Please provide category parameter",nil);
       // failureCallback(@[@"Please provide eLoc parameter"]);
        return;
    }
    category = [map objectForKey:@"category"];

    if ([map objectForKey:@"path"] == nil){
        reject(REQUIRED_CODE,@"Please provide path parameter",nil);
        //failureCallback(@[@"Please provide eLoc parameter"]);
        return;
    }
    routePath = [map objectForKey:@"path"];

    MapmyIndiaPOIAlongTheRouteManager * poiAlongTheRouteManager = [MapmyIndiaPOIAlongTheRouteManager sharedManager];


    MapmyIndiaPOIAlongTheRouteOptions * poiAlongTheRouteOptions = [[MapmyIndiaPOIAlongTheRouteOptions alloc] initWithPath:routePath category:category];



    [poiAlongTheRouteManager getPOIsAlongTheRoutekWithOptions:poiAlongTheRouteOptions completionHandler:^(NSArray<MapmyIndiaPOISuggestion *> * _Nullable suggestions, NSError * _Nullable error) {
        if (error) {
            NSLog(@"%@", error);
            reject(@"0",error.description,nil);
            //failureCallback(@[error.description]);
        } else if (suggestions.count>0) {
            NSString *jsonString = [self poiAlongRouteResponse:suggestions];
            resolve(jsonString);
           // successCallback(@[@200,jsonString]);
            return;
        }else{
            NSDictionary *resultDict = @{@"suggestedPOIs":@[]};
            //successCallback(@[@200,[resultDict toJSONString]]);
            resolve([resultDict toJSONString]);
            return ;
        }
    }];

}


//Feedback  api
RCT_EXPORT_METHOD(feedback:(nonnull NSDictionary *) map resolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)
{


    if ([map objectForKey:@"typedKeyword"] == nil){
        reject(REQUIRED_CODE,@"Please provide typedKeyword parameter",nil);
       // failureCallback(@[@"Please provide typedKeyword parameter"]);
        return;
    }


    if ([map objectForKey:@"eLoc"] == nil){
        reject(REQUIRED_CODE,@"Please provide eLoc parameter",nil);
        //failureCallback(@[@"Please provide eLoc parameter"]);
        return;
    }

    if ([map objectForKey:@"index"] == nil){
        reject(REQUIRED_CODE,@"Please provide index parameter",nil);
        //failureCallback(@[@"Please provide index parameter"]);
        return;
    }

    if ([map objectForKey:@"appVersion"] == nil){
        reject(REQUIRED_CODE,@"Please provide appVersion parameter",nil);
        //failureCallback(@[@"Please provide appVersion parameter"]);
        return;
    }
    if ([map objectForKey:@"locationName"] == nil){
        reject(REQUIRED_CODE,@"Please provide locationName parameter",nil);
        //failureCallback(@[@"Please provide locationName parameter"]);
        return;
    }
    if ([map objectForKey:@"userName"] == nil){
        reject(REQUIRED_CODE,@"Please provide userName parameter",nil);
        //failureCallback(@[@"Please provide userName parameter"]);
        return;
    }
    if ([map objectForKey:@"latitude"] == nil){
        reject(REQUIRED_CODE,@"Please provide latitude parameter",nil);
        //failureCallback(@[@"Please provide latitude parameter"]);
        return;
    }
    if ([map objectForKey:@"longitude"] == nil){
        reject(REQUIRED_CODE,@"Please provide longitude parameter",nil);
       // failureCallback(@[@"Please provide longitude parameter"]);
        return;
    }


    NSString * typedKeyWord = [map objectForKey:@"typedKeyword"];
    NSString * eLoc = [map objectForKey:@"eLoc"];
    NSNumber * index = [map objectForKey:@"index"];
    NSString * appVersion = [map objectForKey:@"appVersion"];
    NSString * locationName = [map objectForKey:@"locationName"];
    NSString * userName = [map objectForKey:@"userName"];
    NSNumber * latitude = [map objectForKey:@"latitude"];
    NSNumber * longitude = [map objectForKey:@"longitude"];

    MapmyIndiaFeedbackManager * feedBackManager = [MapmyIndiaFeedbackManager sharedManager];

   MapmyIndiaFeedbackOptions * feedBackOptions = [[MapmyIndiaFeedbackOptions alloc] initWithTypedKeyword:typedKeyWord selectedEloc:eLoc selectedLocationName:locationName selectedIndex:[index intValue] username:userName appVersion:appVersion latitude:[latitude doubleValue] longitude:[longitude doubleValue]];

    [feedBackManager sendFeedbackWithOptions:feedBackOptions completionHandler:^(BOOL isSuccess, NSError * _Nullable error) {
        if (error) {
            NSLog(@"%@", error);
            reject(@"0",error.description,nil);
           // failureCallback(@[error.description]);
            return;
        } else if (isSuccess) {
            resolve(@"success");
           // successCallback(@[@200,@""]);
            return;
        }
    }];

}


//TODO: CHECK WITH DOCUMENTION
//direction  api
RCT_EXPORT_METHOD(direction:(nonnull NSDictionary *) map resolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)
{

    NSMutableArray * waypoints = [NSMutableArray array];

       if ([map objectForKey:@"origin"] != nil){
           NSString * origin = [map objectForKey:@"origin"];
           NSArray * originArray = [origin componentsSeparatedByString:@","];
           MBWaypoint *originWaypoint = [[MBWaypoint alloc]  initWithCoordinate:CLLocationCoordinate2DMake([originArray[1] doubleValue], [originArray[0] doubleValue]) coordinateAccuracy:-1 name:nil];
           [waypoints addObject: originWaypoint];
        }else{
            reject(REQUIRED_CODE,@"Please provide origin parameter",nil);
      //  failureCallback(@[@"Please provide origin parameter"]);
        return;
        }

    if ([map objectForKey:@"waypoints"] != nil){
        NSArray * wayPoints = [map objectForKey:@"waypoints"];
        for (int i=0; i<wayPoints.count; i++) {
            NSString * wayPoint = wayPoints[i];
            NSArray * wayPointArray = [wayPoint componentsSeparatedByString:@","];
            MBWaypoint *viaWaypoint = [[MBWaypoint alloc]  initWithCoordinate:CLLocationCoordinate2DMake([wayPointArray[1] doubleValue], [wayPointArray[0] doubleValue]) coordinateAccuracy:-1 name:nil];
            [waypoints addObject: viaWaypoint];
        }
    }

       if ([map objectForKey:@"destination"] != nil){
           NSString * destination = [map objectForKey:@"destination"];
           NSArray * destinationArray = [destination componentsSeparatedByString:@","];
           MBWaypoint *destinationWaypoint = [[MBWaypoint alloc]  initWithCoordinate:CLLocationCoordinate2DMake([destinationArray[1] doubleValue], [destinationArray[0] doubleValue]) coordinateAccuracy:-1 name:nil];
           [waypoints addObject: destinationWaypoint];
       }else{
           reject(REQUIRED_CODE,@"Please provide destination parameter",nil);
       // failureCallback(@[@"Please provide destination parameter"]);
        return;
        }

    MBDirectionsProfileIdentifier profile = MBDirectionsProfileIdentifierDriving;
    if([map objectForKey: @"profile"] != nil) {
        NSString * profileText = [map objectForKey: @"profile"];
        if([profileText isEqual:@ "biking"]) {
            profile = MBDirectionsProfileIdentifierBiking;
        } else if([profileText isEqual: @"trucking"]) {
            profile = MBDirectionsProfileIdentifierTrucking;
        } else if([profileText isEqual: @"walking"]) {
            profile = MBDirectionsProfileIdentifierWalking;
        } else {
            profile = MBDirectionsProfileIdentifierDriving;
        }
    }



MBDirectionsResourceIdentifier resource = MBDirectionsResourceIdentifierRouteAdv;
if([map objectForKey: @"resource"] != nil) {
    NSString * resourceText = [map objectForKey: @"resource"];
    if([resourceText isEqual:@ "route_eta"]) {
        resource = MBDirectionsResourceIdentifierRouteETA;
    } else if([resourceText isEqual: @"route_traffic"]) {
        resource = MBDirectionsResourceIdentifierRouteTraffic;
    } else  {
        resource = MBDirectionsResourceIdentifierRouteAdv;
    }
}
    MBRouteOptions *routeOptions = [[MBRouteOptions alloc] initWithWaypoints:waypoints resourceIdentifier: resource profileIdentifier: profile];

    [self addDirectionsOptions:map routeOptions:routeOptions];



    NSURLSessionDataTask *task = [[[MBDirections alloc] initWithRestKey: MapmyIndiaAccountManager.restAPIKey]
                                  calculateDirectionsWithOptions:routeOptions completionHandler:^(NSArray<MBWaypoint *> * _Nullable waypoints, NSArray<MBRoute *> * _Nullable routes, NSError * _Nullable error) {
        if (error) {
            NSLog(@"%@", error);
            reject(@"0",error.description,nil);
            //failureCallback(@[error.description]);
        } else{
            NSString *jsonString = [self directionResponse:waypoints routes:routes];
            //successCallback(@[@200,jsonString]);
            resolve(jsonString);
            return;
        }

       }];


    [task resume];

}

//textSearch  api
RCT_EXPORT_METHOD(textSearch:(nonnull NSDictionary *) map resolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)
{

    NSString * query;
    CLLocation *cLocation;
      if ([map objectForKey:@"query"] != nil){
          query = [map objectForKey:@"query"];
       }else{
           reject(REQUIRED_CODE,@"Please provide query parameter",nil);
       // failureCallback(@[@"Please provide query parameter"]);
        return;
      }

    if ([map objectForKey:@"location"] != nil){
        NSDictionary * location = [map objectForKey:@"location"];
        if ([location objectForKey:@"latitude"] != nil && [location objectForKey:@"longitude"] != nil) {
            NSNumber * longitude = [map objectForKey:@"longitude"] ;
            NSNumber * latitude = [map objectForKey:@"latitude"] ;
            cLocation = [[CLLocation alloc] initWithLatitude:[latitude doubleValue] longitude:[longitude doubleValue]];
        }else{
            reject(REQUIRED_CODE,@"Please provide longitude or latitude parameter",nil);
            //failureCallback(@[@"Please provide longitude or latitude parameter"]);
            return;
        }

     }else{
         reject(REQUIRED_CODE,@"Please provide location parameter",nil);
     // failureCallback(@[@"Please provide query parameter"]);
      return;
    }

    MapmyIndiaAtlasTextSearchManager * textSearchManger = [MapmyIndiaAtlasTextSearchManager sharedManager];

    MapmyIndiaTextSearchAtlasOptions * textSearchOptions = [[MapmyIndiaTextSearchAtlasOptions alloc]initWithQuery:query location:cLocation withRegion:MMIRegionTypeIdentifierIndia];

    [self addTextSearchOptions:map textSearchOptions:textSearchOptions];

    [textSearchManger getTextSearchResultWithOptions:textSearchOptions completionHandler:^(NSArray<MapmyIndiaAtlasSuggestion *> * _Nullable suggestions, NSError * _Nullable error) {

        if (error) {
            NSLog(@"%@", error);
            reject(@"0",error.description,nil);
        //failureCallback(@[error.description]);
    } else if (suggestions.count > 0) {
        NSString *jsonString = [self autoSuggestResponse:suggestions];
        resolve(jsonString);
       // successCallback(@[@200,jsonString]);
        return;

    } else {
        NSDictionary *dict = @{@"suggestedLocations":@[]};
        resolve([dict toJSONString]);
       // successCallback(@[@200,dict]);
    }

    }];



}


- (void) callEndSession {
    //[[MapmyIndiaEndSessionManager alloc] initWithClientId:nil clientSecret:nil grantType:nil sessionType:MapmyIndiaSessionTypeGlobal];
    //[[MapmyIndiaEndSessionManager alloc] initWithClientId:nil clientSecret:nil grantType:nil sessionType:MapmyIndiaSessionTypeNavigation];

}

RCT_EXPORT_METHOD(MapmyIndiaClusterLinkedDevices:(nonnull NSDictionary *) map resolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)
{

    if ([map objectForKey:@"clusterId"] == nil){
        reject(REQUIRED_CODE,@"Please provide clusterId",nil);
        return;
     }

    if ([map objectForKey:@"sessionType"] != nil) {
        NSNumber * sessionType =  [map objectForKey:@"sessionType"];
        [[MapmyIndiaEndSessionManager alloc] initWithClientId:nil clientSecret:nil grantType:nil sessionType:[self setSessionType:sessionType]];
    }

    NSString * clusterId = [map objectForKey:@"clusterId"];

    MapmyIndiaClusterLinkedDevicesManager * clusterLinkedDevicesManager = MapmyIndiaClusterLinkedDevicesManager.sharedManager;
    MapmyIndiaClusterLinkedDevicesOptions * clusterLinkedDevicesOptions = [[MapmyIndiaClusterLinkedDevicesOptions alloc] initWithSessionDevice:clusterId];
    [clusterLinkedDevicesManager getClusterLinkedDevicesWithOptions:clusterLinkedDevicesOptions completionHandler:^(NSArray<MapmyIndiaClusterLinkedDevice *> * _Nullable devices, NSError * _Nullable error) {
        if (error) {
            NSLog(@"%@", error.localizedDescription);
            reject([@(error.code) stringValue],error.localizedDescription,nil);
        } else if (devices) {
            NSString *jsonString = [self linkedDevicesResponse:devices];
            resolve(jsonString);
        } else {
            reject(@"0",@"Unknown Error.",nil);
           // NSLog(@"%@", @"Unknown Error.");
        }
    }];
}


RCT_EXPORT_METHOD(MapmyIndiaDeleteClusterLinkedDevice:(nonnull NSDictionary *) map resolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)
{

    if ([map objectForKey:@"linkedDevice"] == nil){
        reject(REQUIRED_CODE,@"Please provide linkedDevice",nil);
        return;
     }

    if ([map objectForKey:@"clusterId"] == nil){
        reject(REQUIRED_CODE,@"Please provide clusterId",nil);
        return;
     }

    if ([map objectForKey:@"sessionType"] != nil) {
        NSNumber * sessionType =  [map objectForKey:@"sessionType"];
        [[MapmyIndiaEndSessionManager alloc] initWithClientId:nil clientSecret:nil grantType:nil sessionType:[self setSessionType:sessionType]];
    }

    NSString * clusterId = [map objectForKey:@"clusterId"];
    NSString * linkedDevice = [map objectForKey:@"linkedDevice"];

    MapmyIndiaDeleteClusterLinkedDeviceManager * deleteClusterLinkedDevicesManager = MapmyIndiaDeleteClusterLinkedDeviceManager.sharedManager;
    MapmyIndiaDeleteClusterLinkedDeviceOptions * deleteClusterLinkedDevicesOptions = [[MapmyIndiaDeleteClusterLinkedDeviceOptions alloc] initWithSessionDevice:clusterId linkedDevice: linkedDevice];
    [deleteClusterLinkedDevicesManager deleteClusterLinkedDeviceWithOptions:deleteClusterLinkedDevicesOptions completionHandler:^(BOOL isSuccess, NSError * _Nullable error) {
        if (isSuccess) {
            //NSLog(@"%@", @"Device Deleted Succesfully.");
            resolve(@"success");
        } else if (error) {
            reject([@(error.code) stringValue],error.localizedDescription,nil);
           /* NSLog(@"%@", error.localizedDescription);
            if ([[error.localizedDescription lowercaseString] isEqualToString:[@"The operation couldn’t be completed. Could not process request. There is an ongoing session on the provided deviceFingerprint.. Bad Request, User made an error while creating a valid request." lowercaseString]]) {
                [self callEndSession];
            }*/
        } else {
            reject(@"0",@"Unknown Error.",nil);
           // NSLog(@"%@", @"Unknown Error.");
        }
    }];
}



RCT_EXPORT_METHOD(MapmyIndiaEndSession:(nonnull NSDictionary *) map resolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)
{
    if ([map objectForKey:@"clusterId"] == nil){
        reject(REQUIRED_CODE,@"Please provide clusterId",nil);
        return;
     }

    MapmyIndiaEndSessionManager * endSessionManager = MapmyIndiaEndSessionManager.sharedManager;
    if ([map objectForKey:@"sessionType"] != nil) {
        NSNumber * sessionType =  [map objectForKey:@"sessionType"];
        [[MapmyIndiaEndSessionManager alloc] initWithClientId:nil clientSecret:nil grantType:nil sessionType:[self setSessionType:sessionType]];
    }

    NSString * clusterId = [map objectForKey:@"clusterId"];


    MapmyIndiaEndSessionOptions * endSessionOptions = [[MapmyIndiaEndSessionOptions alloc] initWithSessionDevice:clusterId];
    [endSessionManager endSessionWithOptions:endSessionOptions completionHandler:^(BOOL isSuccess, NSError * _Nullable error) {
        if (isSuccess) {
            //NSLog(@"%@", @"Session End Succesfully.");
            resolve(@"success");
        } else if (error) {
            //NSLog(@"%@", error.localizedDescription);
            reject([@(error.code) stringValue],error.localizedDescription,nil);
        } else {
           // NSLog(@"%@", @"Unknown Error.");
            reject(@"0",@"Unknown Error.",nil);
        }
    }];

}

- (NSString *) linkedDevicesResponse:(NSArray<MapmyIndiaClusterLinkedDevice *> *) response {


    NSMutableArray *results = [NSMutableArray array];
    for (int i = 0; i < response.count; i++) {
        MapmyIndiaClusterLinkedDevice *item= response[i];

        NSDictionary *data = @{
            @"deviceAlias": item.alias?item.alias:@"",
            @"deviceFingerprint": item.linkedDevice?item.linkedDevice:@"",

        };
        [results addObject:data];
    }
    return [results toJSONString];
}

-(MapmyIndiaSessionType) setSessionType:(NSNumber *)priority {
    switch ([priority intValue]) {
        case 0:
            return MapmyIndiaSessionTypeGlobal;
        case 1:
            return MapmyIndiaSessionTypeGlobal;
    }
    return MapmyIndiaSessionTypeGlobal;
}


//Helper methods for RestApis
- (void) addGeocodeOptions:(NSDictionary *) map atlasGeocodeOptions :(MapmyIndiaAtlasGeocodeOptions *) mAtlasGeocodeOptions  {

    //add options in future release
    //bias,bound,podfilter


    if ([map objectForKey:@"itemCount"] != nil){
        NSNumber * count = [map objectForKey:@"itemCount"];
        mAtlasGeocodeOptions.maximumResultCount=[count intValue];
    }

}


-(void) addAutoSuggestOptions:(NSDictionary *)map autoSuggesstOptions :(MapmyIndiaAutoSearchAtlasOptions *) mAutoSuggestOptions {

    if ([map objectForKey:@"zoom"] != nil){
        NSNumber * zoom = [map objectForKey:@"zoom"];
        mAutoSuggestOptions.zoom = zoom;
    }

    if ([map objectForKey:@"tokenizeAddress"] != nil){
        BOOL  tokenizeAddress = [[map objectForKey:@"tokenizeAddress"] boolValue];
        if (tokenizeAddress) {
            mAutoSuggestOptions.includeTokenizeAddress=tokenizeAddress;
        }
    }

    if ([map objectForKey:@"location"] != nil){
        NSDictionary * location = [map objectForKey:@"location"];
        if ([location objectForKey:@"latitude"] != nil && [location objectForKey:@"longitude"] != nil) {
            NSNumber * lat = [location objectForKey:@"latitude"];
            NSNumber * lng = [location objectForKey:@"longitude"];
            mAutoSuggestOptions.location  = [[CLLocation alloc] initWithLatitude:[lat doubleValue] longitude:[lng doubleValue]];
        }
    }

    if ([map objectForKey:@"filter"] != nil){
        NSString * filter = [map objectForKey:@"filter"];
        if ([filter containsString:@"cop"]) {
            NSArray *filterArray = [filter componentsSeparatedByString:@":"];
            mAutoSuggestOptions.filter = [[MapmyIndiaElocFilter alloc]initWithPlaceId:filterArray[1]];

        }else{
            NSArray *filterArray = [filter componentsSeparatedByString:@":"];
            NSArray *boundsArray = [filterArray[1] componentsSeparatedByString:@";"];

            NSArray *firstBound = [boundsArray[0] componentsSeparatedByString:@","];
            NSArray *secondBound = [boundsArray[1] componentsSeparatedByString:@","];

            double firstLng = [ firstBound[1] doubleValue ];
            double firstLat = [ firstBound[0] doubleValue ];
            double secondLng = [ secondBound[1] doubleValue ];
            double secondLat = [ secondBound[0] doubleValue ];

            CLLocationCoordinate2D southWest = CLLocationCoordinate2DMake(firstLat, firstLng);
            CLLocationCoordinate2D northeast = CLLocationCoordinate2DMake(secondLat, secondLng);

            mAutoSuggestOptions.filter = [[MapmyIndiaBoundsFilter alloc] initWithBounds:[[MapmyIndiaRectangularRegion alloc] initWithTopLeft:northeast bottomRight:southWest]];
        }

    }

    if ([map objectForKey:@"pod"] != nil){
        NSString * pod = [map objectForKey:@"pod"];
        //TODO:To be checked
        mAutoSuggestOptions.pod = pod;
    }

}


-(void) addDirectionsOptions:(NSDictionary *)map routeOptions :(MBRouteOptions *) mRouteOptions {
//    if (readableMap.hasKey("excludes")) {
//              ReadableArray excludesArray = readableMap.getArray("excludes");
//              String[] excludes = new String[excludesArray.size()];
//              for (int i = 0; i < excludesArray.size(); i++) {
//                  excludes[i] = excludesArray.getString(i);
//              }
//              mBuilder.excludes(excludes);
//     }
//            if (readableMap.hasKey("annotations")) {
//                ReadableArray annotationsArray = readableMap.getArray("annotations");
//                String[] annotations = new String[annotationsArray.size()];
//                for (int i = 0; i < annotationsArray.size(); i++) {
//                    annotations[i] = annotationsArray.getString(i);
//                }
//                mBuilder.annotations(annotations);
//            }
//
//            if (readableMap.hasKey("approaches")) {
//                ReadableArray approachesArray = readableMap.getArray("approaches");
//                String[] approaches = new String[approachesArray.size()];
//                for (int i = 0; i < approachesArray.size(); i++) {
//                    approaches[i] = approachesArray.getString(i);
//                }
//                mBuilder.addApproaches(approaches);
//            }
//            if (readableMap.hasKey("bearing")) {
//                ReadableMap bearing = readableMap.getMap("bearing");
//                if (bearing.hasKey("angle") && bearing.hasKey("tolerance")) {
//                    mBuilder.addBearing(bearing.getDouble("angle"), bearing.getDouble("tolerance"));
//                }
//            }
//            if (readableMap.hasKey("waypointIndices")) {
//                ReadableArray waypointIndicesArray = readableMap.getArray("waypointIndices");
//                Integer[] waypointIndices = new Integer[waypointIndicesArray.size()];
//                for (int i = 0; i < waypointIndicesArray.size(); i++) {
//                    waypointIndices[i] = waypointIndicesArray.getInt(i);
//                }
//                mBuilder.addWaypointIndices(waypointIndices);
//            }
//            if (readableMap.hasKey("waypointNames")) {
//                ReadableArray waypointNamesArray = readableMap.getArray("waypointNames");
//                String[] waypointNames = new String[waypointNamesArray.size()];
//                for (int i = 0; i < waypointNamesArray.size(); i++) {
//                    waypointNames[i] = waypointNamesArray.getString(i);
//                }
//                mBuilder.addWaypointNames(waypointNames);
//            }
//            if (readableMap.hasKey("waypointTargets")) {
//                ReadableArray waypointTargetsArray = readableMap.getArray("waypointTargets");
//                Point[] waypointTargets = new Point[waypointTargetsArray.size()];
//                for (int i = 0; i < waypointTargetsArray.size(); i++) {
//                    ReadableMap waypointTargetsMap = waypointTargetsArray.getMap(i);
//                    if (waypointTargetsMap.hasKey("latitude") && waypointTargetsMap.hasKey("longitude")) {
//                        waypointTargets[i] = Point.fromLngLat(waypointTargetsMap.getDouble("longitude"), waypointTargetsMap.getDouble("longitude"));
//                    }
//                }
//                mBuilder.addWaypointTargets(waypointTargets);
//            }
//            if (readableMap.hasKey("isSort")) {
//                mBuilder.isSort(readableMap.getBoolean("isSort"));
//            }
//            if (readableMap.hasKey("lessVerbose")) {
//                mBuilder.lessVerbose(readableMap.getBoolean("lessVerbose"));
//            }

//            if (readableMap.hasKey("radiuses")) {
//                ReadableArray radiusesArray = readableMap.getArray("radiuses");
//                double[] radiuses = new double[radiusesArray.size()];
//                for (int i = 0; i < radiusesArray.size(); i++) {
//                    radiuses[i] = radiusesArray.getDouble(i);
//                }
//                mBuilder.radiuses(radiuses);
//            }

//            if (readableMap.hasKey("deviceId")) {
//                mBuilder.deviceId(readableMap.getString("deviceId"));
//            }
//            if (readableMap.hasKey("sessionId")) {
//                mBuilder.sessionId(readableMap.getString("sessionId"));
//            }
//            if (readableMap.hasKey("voiceUnits")) {
//                mBuilder.voiceUnits(readableMap.getString("voiceUnits"));
//            }



    if ([map objectForKey:@"overview"] != nil){
        NSNumber  *overview = [map objectForKey:@"overview"];
        //TODO: NEED TO CHECKED
        mRouteOptions.routeShapeResolution=[overview intValue];
    }
    if([map objectForKey:@"geometries"] != nil) {
        NSString * geometries = [map objectForKey: @"geometries"];
        if([geometries  isEqual: @"polyline"]) {
        mRouteOptions.shapeFormat = MBRouteShapeFormatPolyline;
        } else {
            mRouteOptions.shapeFormat = MBRouteShapeFormatPolyline6;
        }
    } else {
        mRouteOptions.shapeFormat = MBRouteShapeFormatPolyline6;
    }
    if([map objectForKey:@"annotations"] != nil) {
        NSArray * annotations = [map objectForKey:@"annotations"];

        for(int i = 0; i<annotations.count; i++) {
            NSString * annotation = annotations[i];
            if([annotation isEqual:@"congestion"]) {
                mRouteOptions.attributeOptions |= MBAttributeCongestionLevel;
            }
            if([annotation isEqual: @"nodes"]) {
                mRouteOptions.attributeOptions |= MBAttributeNodes;
            }
            if([annotation isEqual: @"baseDuration"]) {
                mRouteOptions.attributeOptions |= MBAttributeBaseDuration;
            }
            if([annotation isEqual: @"speed"]) {
                mRouteOptions.attributeOptions |= MBAttributeSpeed;
            }
        }


    }

    if ([map objectForKey:@"alternatives"] != nil){
        BOOL  alternatives = [[map objectForKey:@"alternatives"] boolValue];
        mRouteOptions.includesAlternativeRoutes=alternatives;
    }
    if ([map objectForKey:@"steps"] != nil){
        BOOL  steps = [[map objectForKey:@"steps"] boolValue];
        mRouteOptions.includesSteps=steps;
    }

    if ([map objectForKey:@"bannerInstructions"] != nil){
        BOOL  bannerInstructions = [[map objectForKey:@"bannerInstructions"] boolValue];
        mRouteOptions.includesVisualInstructions=bannerInstructions;
    }

    if ([map objectForKey:@"profile"] != nil){
        NSString  *profile = [map objectForKey:@"profile"];
        //TODO: NEED TO CHECKED
        mRouteOptions.profileIdentifier=profile;
    }

    if ([map objectForKey:@"resource"] != nil){
        NSString  *resource = [map objectForKey:@"resource"];
        //TODO: NEED TO CHECKED
        mRouteOptions.resourceIdentifier=resource;
    }

    if ([map objectForKey:@"voiceInstructions"] != nil){
        BOOL  voiceInstructions = [[map objectForKey:@"voiceInstructions"] boolValue];
        mRouteOptions.includesSpokenInstructions=voiceInstructions;
    }

    if ([map objectForKey:@"roundaboutExits"] != nil){
        BOOL  roundaboutExits = [[map objectForKey:@"roundaboutExits"] boolValue];
        mRouteOptions.includesExitRoundaboutManeuver=roundaboutExits;
    }

    if ([map objectForKey:@"routeRefresh"] != nil){
        BOOL  routeRefresh = [[map objectForKey:@"routeRefresh"] boolValue];
        mRouteOptions.routeRefresh=routeRefresh;
    }



}

-(void) addNearbyOptions:(NSDictionary *)map nearbyOptions :(MapmyIndiaNearbyAtlasOptions *) mNearbyOptions {


    if ([map objectForKey:@"bounds"] != nil){
        NSString * bounds = [map objectForKey:@"bounds"];

        NSArray *boundsArray = [bounds componentsSeparatedByString:@";"];

        NSArray *firstBound = [boundsArray[0] componentsSeparatedByString:@","];
        NSArray *secondBound = [boundsArray[1] componentsSeparatedByString:@","];

        double firstLng = [ firstBound[1] doubleValue ];
        double firstLat = [ firstBound[0] doubleValue ];
        double secondLng = [ secondBound[1] doubleValue ];
        double secondLat = [ secondBound[0] doubleValue ];

        CLLocationCoordinate2D southWest = CLLocationCoordinate2DMake(firstLat, firstLng);
        CLLocationCoordinate2D northeast = CLLocationCoordinate2DMake(secondLat, secondLng);
        mNearbyOptions.bounds =[[MapmyIndiaRectangularRegion alloc]initWithTopLeft:northeast bottomRight:southWest];
    }

    if ([map objectForKey:@"filter"] != nil){
        NSString * filter = [map objectForKey:@"filter"];
        NSArray *filterArray = [filter componentsSeparatedByString:@":"];
        mNearbyOptions.filters = @[ [[MapmyIndiaNearbyKeyValueFilter alloc]initWithFilterKey:filterArray[0] filterValues:@[filterArray[1]]]];
    }

    if ([map objectForKey:@"page"] != nil){
        NSNumber * page =[map objectForKey:@"page"];
        mNearbyOptions.page= page;
        }

    if ([map objectForKey:@"pod"] != nil){
        NSString * pod =[map objectForKey:@"pod"];
        //TODO: check while running
        mNearbyOptions.pod= pod;
        }

    if ([map objectForKey:@"radius"] != nil){
        NSNumber * radius =[map objectForKey:@"radius"];
        mNearbyOptions.radius= radius;
        }

    if ([map objectForKey:@"searchBy"] != nil){
        NSString * searchBy =[map objectForKey:@"searchBy"];
        //To be confirmed
        //mNearbyOptions.searchBy= [MMISearchByTypeDistance initWithString:searchBy];
        }

    if ([map objectForKey:@"sortBy"] != nil){
        NSString * sortBy =[map objectForKey:@"sortBy"];
        if ([sortBy isEqualToString:@"dist:asc"] || [sortBy isEqualToString:@"dist:desc"]) {
           //to be confirmed
            //mNearbyOptions.sortBy = [[MapmyIndiaSortByWithOrder alloc] initWithOrderBy:[MMISortByOrderTypeAscending initWithString:sortBy]];
        }else if ([sortBy isEqualToString:@"name:asc"] || [sortBy isEqualToString:@"name:desc"]) {
            //to be checked
        }
        }


}

-(void) addDistanceMatrixOptions:(NSDictionary *)map distanceMatrixOptions :(MapmyIndiaDrivingDistanceMatrixOptions *) mDistanceMatrixOptions {

    if ([map objectForKey:@"profile"] != nil){
        NSString * profile =[map objectForKey:@"profile"];
        //To be confirmed
        mDistanceMatrixOptions.profileIdentifier = MapmyIndiaDirectionsProfileIdentifierDriving;
        }

    if ([map objectForKey:@"resource"] != nil){
        NSString * resource =[map objectForKey:@"resource"];
        //To be confirmed
        mDistanceMatrixOptions.profileIdentifier = MapmyIndiaDistanceMatrixResourceIdentifierDefault;
        }

}

-(void) addPOIAlongRouteOptions:(NSDictionary *)map poiAlongRouteOptions :(MapmyIndiaPOIAlongTheRouteOptions *) mPoiAlongRouteOptions {

    if ([map objectForKey:@"buffer"] != nil){
        NSNumber * buffer =[map objectForKey:@"buffer"];
        mPoiAlongRouteOptions.buffer = [buffer intValue];
        }

    if ([map objectForKey:@"geometries"] != nil){
        NSString * geometries =[map objectForKey:@"geometries"];
        //To be confirmed
        mPoiAlongRouteOptions.geometries = MMIPolylineGeometryTypeBase64;
        }

    if ([map objectForKey:@"page"] != nil){
        NSNumber * page =[map objectForKey:@"page"];
        mPoiAlongRouteOptions.page = [page intValue];
        }
    if ([map objectForKey:@"sort"] != nil){
        BOOL  sort = [[map objectForKey:@"sort"] boolValue];
        mPoiAlongRouteOptions.sort = sort;
        }
}


-(void) addTextSearchOptions:(NSDictionary *)map textSearchOptions :( MapmyIndiaTextSearchAtlasOptions*) mTextSearchOptions {

    if ([map objectForKey:@"bridge"] != nil){
        //need to check
        }

    if ([map objectForKey:@"explain"] != nil){
        //need to check
        }

    if ([map objectForKey:@"filter"] != nil){
        //need to check
        }

    if ([map objectForKey:@"username"] != nil){
        //need to check
        }
}

- (NSString *) reverseGeoCodeResponse:(NSArray<MapmyIndiaGeocodedPlacemark *> *) response {


    NSMutableArray *results = [NSMutableArray array];
    for (int i = 0; i < response.count; i++) {
        MapmyIndiaGeocodedPlacemark *item= response[i];

        NSDictionary *data = @{
            @"area": item.area?item.area:@"",
            @"houseNumber": item.houseNumber?item.houseNumber:@"",
            @"houseName": item.houseName?item.houseName:@"",
            @"poi": item.poi?item.poi:@"",
            @"poi_dist": item.poiDist?item.poiDist:@"",
            @"street": item.street?item.street:@"",
            @"street_dist": item.streetDist?item.streetDist:@"",
            @"subSubLocality": item.subSubLocality?item.subSubLocality:@"",
            @"subLocality": item.subLocality?item.subLocality:@"",
            @"locality": item.locality?item.locality:@"",
            @"village": item.village?item.village:@"",
            @"subDistrict": item.subDistrict?item.subDistrict:@"",
            @"district": item.district?item.district:@"",
            @"city": item.city?item.city:@"",
            @"state": item.state?item.state:@"",
            @"pincode": item.pincode?item.pincode:@"",
            @"formatted_address": item.formattedAddress?item.formattedAddress:@"",
            @"place_id": item.placeId?item.placeId:@"",
            @"lat": item.latitude?item.latitude:@"",
            @"lng": item.longitude?item.longitude:@""

        };
        [results addObject:data];
    }
    NSDictionary *dict = @{@"results":results,@"responseCode":@200};
    return [dict toJSONString];
}


- (NSString *) geoCodeResponse:(MapmyIndiaAtlasGeocodeAPIResponse *) response {

    if (response==nil) {
        return nil;
    }

    NSMutableArray *results = [NSMutableArray array];


    for (int i = 0; i < response.placemarks.count; i++) {
        MapmyIndiaAtlasGeocodePlacemark *item= response.placemarks[i];

        NSDictionary *data = @{
            @"houseNumber": item.houseNumber?item.houseNumber:@"",
            @"houseName": item.houseName?item.houseName:@"",
            @"poi": item.poi?item.poi:@"",
            @"street": item.street?item.street:@"",
            @"subSubLocality": item.subSubLocality?item.subSubLocality:@"",
            @"subLocality": item.subLocality?item.subLocality:@"",
            @"locality": item.locality?item.locality:@"",
            @"village": item.village?item.village:@"",
            @"subDistrict": item.subDistrict?item.subDistrict:@"",
            @"district": item.district?item.district:@"",
            @"city": item.city?item.city:@"",
            @"state": item.state?item.state:@"",
            @"pincode": item.pincode?item.pincode:@"",
            @"formattedAddress": item.formattedAddress?item.formattedAddress:@"",
            @"eLoc": item.eLoc?item.eLoc:@"",
            @"latitude": item.latitude?item.latitude:@"",
            @"longitude": item.longitude?item.longitude:@"",
            @"geocodeLevel": item.geocodeLevel?item.geocodeLevel:@""

        };
        [results addObject:data];
    }

    NSDictionary *dict = @{@"results":results,@"responseCode":@200};
    return [dict toJSONString];
}



- (NSString *) autoSuggestResponse:(NSArray<MapmyIndiaAtlasSuggestion *> *) response {

    NSMutableArray *suggestedLocations = [NSMutableArray array];
    for (int i = 0; i < response.count; i++) {
        MapmyIndiaAtlasSuggestion *item= response[i];

        NSMutableDictionary *addresstokens = [[NSMutableDictionary alloc] init];

        if (item.addressTokens!=nil) {
            [addresstokens setObject:item.addressTokens.poi?item.addressTokens.poi:@"" forKey:@"poi"];
            [addresstokens setObject:item.addressTokens.city?item.addressTokens.city:@"" forKey:@"city"];
            [addresstokens setObject:item.addressTokens.district?item.addressTokens.district:@"" forKey:@"district"];
            [addresstokens setObject:item.addressTokens.houseName?item.addressTokens.houseName:@"" forKey:@"houseName"];
            [addresstokens setObject:item.addressTokens.houseNumber?item.addressTokens.houseNumber:@"" forKey:@"houseNumber"];
            [addresstokens setObject:item.addressTokens.locality?item.addressTokens.locality:@"" forKey:@"locality"];
            [addresstokens setObject:item.addressTokens.pincode?item.addressTokens.pincode:@"" forKey:@"pincode"];
            [addresstokens setObject:item.addressTokens.state?item.addressTokens.state:@"" forKey:@"state"];
            [addresstokens setObject:item.addressTokens.street?item.addressTokens.street:@"" forKey:@"street"];
            [addresstokens setObject:item.addressTokens.subDistrict?item.addressTokens.subDistrict:@"" forKey:@"subDistrict"];
            [addresstokens setObject:item.addressTokens.subLocality?item.addressTokens.subLocality:@"" forKey:@"subLocality"];
            [addresstokens setObject:item.addressTokens.subSubLocality?item.addressTokens.subSubLocality:@"" forKey:@"subSubLocality"];
            [addresstokens setObject:item.addressTokens.village?item.addressTokens.village:@"" forKey:@"village"];
        }


        NSDictionary *data = @{
            @"elc" :item.eLoc?item.eLoc:@"" ,
            @"placeName": item.placeName?item.placeName: @"" ,
            @"addr": item.placeAddress?item.placeAddress:@"" ,
            @"longitude": item.longitude?item.longitude:@"",
            @"latitude": item.latitude?item.latitude:@"",
            @"type": item.type?item.type:@"",
            //"entryLatitude": item.entry?item.entryLatitude:@0.0,
            //"entryLongitude": item.entryLongitude ? item.entryLongitude:0.0,
            @"orderIndex": item.orderIndex ?item.orderIndex: @0,
            @"keywords": item.keywords? item.keywords:@"",
            @"typeX": item.typeX ? item.typeX: @"",
            @"addressTokens": addresstokens?addresstokens:@{}



        };
        [suggestedLocations addObject:data];
    }
    NSDictionary *dict = @{@"suggestedLocations":suggestedLocations};
    return [dict toJSONString];

}

- (NSString *) nearByResponse:(MapmyIndiaNearbyResult *) response {
    if (response==nil) {
        return nil;
    }
    NSMutableArray *suggestedLocations = [NSMutableArray array];
    if (response.suggestions!=nil) {
        for (int i = 0; i < response.suggestions.count; i++) {
            MapmyIndiaAtlasSuggestion *item= response.suggestions[i];

            NSMutableDictionary *addresstokens = nil;

            if (item.addressTokens!=nil) {
                addresstokens = [[NSMutableDictionary alloc] init];

                [addresstokens setObject:item.addressTokens.poi?item.addressTokens.poi:@"" forKey:@"poi"];
                [addresstokens setObject:item.addressTokens.city?item.addressTokens.city:@"" forKey:@"city"];
                [addresstokens setObject:item.addressTokens.district?item.addressTokens.district:@"" forKey:@"district"];
                [addresstokens setObject:item.addressTokens.houseName?item.addressTokens.houseName:@"" forKey:@"houseName"];
                [addresstokens setObject:item.addressTokens.houseNumber?item.addressTokens.houseNumber:@"" forKey:@"houseNumber"];
                [addresstokens setObject:item.addressTokens.locality?item.addressTokens.locality:@"" forKey:@"locality"];
                [addresstokens setObject:item.addressTokens.pincode?item.addressTokens.pincode:@"" forKey:@"pincode"];
                [addresstokens setObject:item.addressTokens.state?item.addressTokens.state:@"" forKey:@"state"];
                [addresstokens setObject:item.addressTokens.street?item.addressTokens.street:@"" forKey:@"street"];
                [addresstokens setObject:item.addressTokens.subDistrict?item.addressTokens.subDistrict:@"" forKey:@"subDistrict"];
                [addresstokens setObject:item.addressTokens.subLocality?item.addressTokens.subLocality:@"" forKey:@"subLocality"];
                [addresstokens setObject:item.addressTokens.subSubLocality?item.addressTokens.subSubLocality:@"" forKey:@"subSubLocality"];
                [addresstokens setObject:item.addressTokens.village?item.addressTokens.village:@"" forKey:@"village"];
            }


            NSDictionary *data = @{
                @"distance": item.distance?item.distance:@"",
                @"eLoc": item.eLoc?item.eLoc:@"",
                @"email": item.email?item.email:@"",
                //@"entryLatitude": item.entryLatitude?item.distance:@"",
               // @"entryLongitude": item.entryLongitude?item.distance:@"",
                @"keywords": item.keywords?item.keywords:@"",
                @"landlineNo": item.landlineNo?item.landlineNo:@"",
                @"latitude": item.latitude?item.latitude:@"",
                @"longitude": item.longitude?item.longitude:@"",
                @"mobileNo": item.mobileNo?item.mobileNo:@"",
                @"orderIndex": item.orderIndex?item.orderIndex:@"",
                @"placeAddress": item.placeAddress?item.placeAddress:@"",
                @"placeName": item.placeName?item.placeName:@"",
                @"type": item.type?item.type:@"",
                @"categoryCode": item.categoryCode?item.categoryCode:@"",
                @"hourOfOperation": item.hourOfOperation?item.hourOfOperation:@"",
                @"richInfo": item.richInfoDictionary?item.richInfoDictionary:@"",
                @"addressTokens": addresstokens?addresstokens:@{}



            };
            [suggestedLocations addObject:data];
        }
    }
    NSMutableDictionary *pageInfoDict = [[NSMutableDictionary alloc] init];

    if (response.pageInfo!=nil) {
        MapmyIndiaPageInfo *pageInfo = response.pageInfo;

        [pageInfoDict setObject:pageInfo.pageCount?pageInfo.pageCount:@0 forKey:@"pageCount"];
        [pageInfoDict setObject:pageInfo.totalHits?pageInfo.totalHits:@0 forKey:@"totalHits"];
        [pageInfoDict setObject:pageInfo.totalPages?pageInfo.totalPages:@0 forKey:@"totalPages"];
        [pageInfoDict setObject:pageInfo.pageSize?pageInfo.pageSize:@0 forKey:@"pageSize"];
    }

    NSDictionary *dict = @{@"suggestedLocations":suggestedLocations,@"pageInfo":pageInfoDict};
    return [dict toJSONString];
}


//Distance Matrix response
- (NSString *) distanceResponse:(MapmyIndiaDrivingDistanceMatrixResponse *) response {

    NSMutableDictionary *results = [[NSMutableDictionary alloc] init];

    if (response.results!=nil) {

        [results setObject:response.results.code?response.results.code:@"" forKey:@"code"];
        [results setObject:response.results.distances?response.results.distances:@"" forKey:@"distances"];
        [results setObject:response.results.durations?response.results.durations:@"" forKey:@"durations"];
    }
    NSDictionary *resultDict = @{@"results":results,@"responseCode":response.responseCode,@"version":response.version};
    return [resultDict toJSONString];
}

- (NSString *) placeDetailResponse:(MapmyIndiaPlaceDetail *) response {


    NSMutableArray *placeKeyInfoList = [NSMutableArray array];

    if (response.keyInfo!=nil) {
        for (int i=0; i<response.keyInfo.count; i++) {
            NSMutableArray *valueList = [NSMutableArray array];
            NSArray<MapmyIndiaPlaceDetailKeyInfoValues *> * values = response.keyInfo[i].values;
            if (values!=nil) {
                for (int k=0; k<values.count; k++) {
                    NSDictionary *valueData = @{@"title":values[i].title,@"value":values[i].value};
                    [valueList addObject:valueData];
                }
            }
            NSDictionary *data = @{@"heading": response.keyInfo[i].heading,@"values":valueList};
            [placeKeyInfoList addObject:data];
        }
    }

    NSDictionary *resultDict = @{
        @"eloc": response.eLoc?response.eLoc:@"",
        @"latitude": response.latitude?response.latitude:@"",
        @"longitude": response.longitude?response.longitude:@"",
        @"placeName": response.placeName?response.placeName:@"",
        @"address": response.address?response.address:@"",
        @"type": response.type?response.type:@"",
        @"houseNumber": response.houseNumber?response.houseNumber:@"",
        @"houseName": response.houseName?response.houseName:@"",
        @"poi": response.poi?response.poi:@"",
        @"street": response.street?response.street:@"",
        @"subSubLocality": response.subSubLocality?response.subSubLocality:@"",
        @"subLocality": response.subLocality?response.subLocality:@"",
        @"locality": response.locality?response.locality:@"",
        @"village": response.village?response.village:@"",
        @"district": response.district?response.district:@"",
        @"subDistrict": response.subDistrict?response.subDistrict:@"",
        @"city": response.city?response.city:@"",
        @"state": response.state?response.state:@"",
        @"pincode": response.pincode?response.pincode:@"",
        @"placeKeyInfo": placeKeyInfoList

    };
    return [resultDict toJSONString];
}

- (NSString *) placeDetailLegacyResponse:(NSArray<MapmyIndiaGeocodedPlacemark *> *) response {

    NSMutableArray *resultArray = [NSMutableArray array];

    for (int i=0; i<response.count; i++) {
        MapmyIndiaGeocodedPlacemark *item = response[i];
        NSDictionary *dict = @{
            @"area": item.area?item.area:@"",
            @"city": item.city?item.city:@"",
            @"district": item.district?item.district:@"",
            @"formatted_address": item.formattedAddress?item.formattedAddress:@"",
            @"houseName": item.houseName?item.houseName:@"",
            @"houseNumber": item.houseNumber?item.houseNumber:@"",
            @"lat": item.latitude?item.latitude:@"",
            @"lng": item.longitude?item.longitude:@"",
            @"locality": item.locality?item.locality:@"",
            @"pincode": item.pincode?item.pincode:@"",
            @"poi_dist": item.poiDist?item.poiDist:@"",
            @"poi": item.poi?item.poi:@"",
            @"state": item.state?item.state:@"",
            @"street": item.street?item.street:@"",
            @"street_dist": item.streetDist?item.streetDist:@"",
            @"subDistrict": item.subDistrict?item.subDistrict:@"",
            @"subLocality": item.subLocality?item.subLocality:@"",
            @"subSubLocality": item.subSubLocality?item.subSubLocality:@"",
            @"village": item.village?item.village:@"",
            @"place_id": item.placeId?item.placeId:@""


        };
        [resultArray addObject:dict];
    }

    NSDictionary *resultDict = @{@"results":resultArray};
    return [resultDict toJSONString];
}


- (NSString *) poiAlongRouteResponse:(NSArray<MapmyIndiaPOISuggestion *> *) response {

    NSMutableArray *suggestedPoi = [NSMutableArray array];

    for (int i=0; i<response.count; i++) {
        MapmyIndiaPOISuggestion *item = response[i];
        NSDictionary *dict = @{
            @"distance": item.distanceObjC?item.distanceObjC:@0,
            @"place_id": item.placeId?item.placeId:@"",
            @"poi": item.poi?item.poi:@"",
            @"subSubLocality": item.subSubLocality?item.subSubLocality:@"",
            @"subLocality": item.subLocality?item.subLocality:@"",
            @"locality": item.locality?item.locality:@"",
            @"city": item.city?item.city:@"",
            @"subDistrict": item.subDistrict?item.subDistrict:@"",
            @"district": item.district?item.district:@"",
            @"state": item.state?item.state:@"",
            @"poplrName": item.popularName?item.popularName:@"",
            @"address": item.address?item.address:@"",
            @"tel": item.telephoneNumber?item.telephoneNumber:@"",
            @"email": item.email?item.email:@"",
            @"website": item.website?item.website:@"",
            @"e_lat": item.entryLatitudeObjC?item.entryLatitudeObjC:@"",
            @"e_lng": item.entryLongitudeObjC?item.entryLongitudeObjC:@"",
            @"latitude": item.latitudeObjC?item.latitudeObjC:@"",
            @"longitude": item.longitudeObjC?item.longitudeObjC:@"",
            @"brand_code": item.brandCode?item.brandCode:@""
        };
        [suggestedPoi addObject:dict];
    }

    NSDictionary *resultDict = @{@"suggestedPOIs":suggestedPoi};
    return [resultDict toJSONString];
}


    - (NSString *) directionResponse:(NSArray<MBWaypoint *> * )wayPoints  routes:(NSArray<MBRoute *> *)  mRoutes  {


        NSMutableArray *wayPointList = [NSMutableArray array];
        NSMutableArray *routesList = [NSMutableArray array];

        for (int i=0; i<wayPoints.count; i++) {
            MBWaypoint *wayPoint = wayPoints[i];
            NSDictionary *data = @{@"location":@[[NSNumber numberWithDouble:wayPoint.coordinate.longitude],[NSNumber numberWithDouble:wayPoint.coordinate.latitude]],@"name":wayPoint.name?wayPoint.name:@""};
            [wayPointList addObject:data];
        }

        for (int k=0; k<mRoutes.count; k++) {
            MBRoute * route= mRoutes[k];


            NSMutableDictionary *data = [NSMutableDictionary dictionary];

            [data setObject:route.distance? [NSNumber numberWithDouble:route.distance]:@0.0 forKey:@"distance"];
            [data setObject:route.expectedTravelTime?[NSNumber numberWithDouble:route.expectedTravelTime]:@0 forKey:@"duration"];

            //TODO: add geometry library
            [data setObject:route.coordinates?[self encodeStringWithCoordinates:route.coordinates]:@0 forKey:@"geometry"];

            [data setObject:[NSNumber numberWithInt:k] forKey:@"routeIndex"];


            if (route.legs!=nil) {
                NSMutableArray *legList = [NSMutableArray array];
                for (int j=0; j<route.legs.count; j++) {
                    MBRouteLeg *leg = route.legs[j];


                    NSMutableDictionary *legsDict = [NSMutableDictionary dictionary];

                    [legsDict setObject: leg.distance? [NSNumber numberWithDouble:leg.distance]:@0.0 forKey:@"distance"];
                    [legsDict setObject:leg.expectedTravelTime? [NSNumber numberWithDouble:leg.expectedTravelTime]:@0.0 forKey:@"duration"];
                    [legsDict setObject:leg.description?leg.description:@"" forKey:@"summary"];


                    NSMutableArray *stepsList = [NSMutableArray array];
                    for (int m =0; m<leg.steps.count; m++) {
                        MBRouteStep * steps = leg.steps[m];
                        NSMutableDictionary *stepsDict = [NSMutableDictionary dictionary];

                        [stepsDict setObject:steps.distance? [NSNumber numberWithDouble:steps.distance]:@0.0 forKey:@"distance"];
                        [stepsDict setObject:steps.expectedTravelTime? [NSNumber numberWithDouble:steps.expectedTravelTime]:@0.0 forKey:@"duration"];
                        //TODO: TO be checked
                        [stepsDict setObject:[self encodeStringWithCoordinates:steps.coordinates] forKey:@"geometry"];


                        [stepsDict setObject:steps.names!=nil&&steps.names.count>0?steps.names[0]:@"" forKey:@"name"];
                        [stepsDict setObject:steps.destinations!=nil&&steps.destinations.count>0?steps.destinations[0]:@"" forKey:@"destinations"];
                        //TODO: use switch case for enums
                        //[stepsDict setObject:steps.transportType?steps.transportType:@"" forKey:@"mode"];
                        [stepsDict setObject:steps.instructions?steps.instructions:@"" forKey:@"pronunciation"];
                        [stepsDict setObject: steps.exitNames!=nil&&steps.exitNames.count>0?steps.exitNames[0]:@"" forKey:@"rotary_name"];
                        [stepsDict setObject: steps.phoneticExitNames!=nil&&steps.phoneticExitNames.count>0?steps.phoneticExitNames[0]:@"" forKey:@"rotary_pronunciation"];
                        //TODO: NOT FOUND
                        //[stepsDict setObject: steps.drivingSide.description forKey:@"driving_side"];

                        [stepsDict setObject: @{
                                        //      "degree": steps.,
                                        @"location":steps.maneuverLocation.latitude&&steps.maneuverLocation.longitude?@[[NSNumber numberWithDouble:steps.maneuverLocation.longitude], [NSNumber numberWithDouble:steps.maneuverLocation.latitude]]:@"",
                                            //TODO: NOT FOUND
                                            // @"bearing_before": steps.initialHeading,
                                            //@"bearing_after": steps.finalHeading,

                                            @"instruction": steps.instructions?steps.instructions:@"",
                                            //TODO: use switch case for enums
                                                 //@"type": steps.maneuverType,//steps.maneuverType.description,
                                                 //@"modifier": steps.maneuverDirection //steps.maneuverDirection.description,
                                                //TODO: NOT FOUND
                                                //@"exit": steps.exitIndex
                                                } forKey:@"maneuver"];


                        if (steps.instructionsSpokenAlongStep!=nil) {
                            NSMutableArray *voiceInstuctionList = [NSMutableArray array];

                            for (int p=0; p<steps.instructionsSpokenAlongStep.count; p++) {
                                MBSpokenInstruction *spokenInstruction= steps.instructionsSpokenAlongStep[p];
                                NSDictionary *spokenDict = @{
                                    @"distanceAlongGeometry": spokenInstruction.distanceAlongStep?[NSNumber numberWithDouble:spokenInstruction.distanceAlongStep]:@0,
                                    @"announcement": spokenInstruction.text?spokenInstruction.text:@"",
                                    @"ssmlAnnouncement": spokenInstruction.ssmlText?spokenInstruction.ssmlText:@""
                                };
                                [voiceInstuctionList addObject:spokenDict];
                                }

                            [stepsDict setObject: voiceInstuctionList forKey:@"voiceInstructions"];

                            if (steps.intersections!= nil) {
                                NSMutableArray *intersectionList = [NSMutableArray array];
                                for (int t=0; t<steps.intersections.count; t++) {
                                    MBIntersection *stepsintersection = steps.intersections[t];
                                    NSMutableDictionary *intersectionDict = [NSMutableDictionary dictionary];
                                    [intersectionDict setObject: stepsintersection.location.latitude&&stepsintersection.location.longitude?@[[NSNumber numberWithDouble:stepsintersection.location.longitude], [NSNumber numberWithDouble:stepsintersection.location.latitude]]:@"" forKey:@"location"];
                                    [intersectionDict setObject: stepsintersection.headings?stepsintersection.headings:@"" forKey:@"bearings"];
                                    NSMutableArray *entries = [NSMutableArray array];

                                    for(int i =0; i< stepsintersection.headings.count; i++) {
                                       [entries addObject: @NO];
                                    }
                                    if(stepsintersection.outletIndexes != nil) {
                                       [stepsintersection.outletIndexes enumerateIndexesUsingBlock:^(NSUInteger idx, BOOL *stop) {
                                          if([entries objectAtIndex: idx]) {
                                              [entries replaceObjectAtIndex: idx withObject: @YES];
                                          }
                                       }];
                                    }
                                    //[intersectionDict setObject: stepsintersection.outletRoadClasses?stepsintersection.outletRoadClasses:@"" forKey:@"classes"];
                                    [intersectionDict setObject:entries forKey:@"entry"];
                                    [intersectionDict setObject: stepsintersection.approachIndex?[NSNumber numberWithLong:stepsintersection.approachIndex]:@0 forKey:@"in"];
                                    [intersectionDict setObject: stepsintersection.outletIndex?[NSNumber numberWithLong:stepsintersection.outletIndex]:@0 forKey:@"out"];


                                    if (stepsintersection.approachLanes!=nil) {
                                        NSMutableArray *lanesList = [NSMutableArray array];
                                        for (int q=0; q<stepsintersection.approachLanes.count; q++) {
                                            MBLane *laneItem = stepsintersection.approachLanes[q];
                                            NSMutableArray *indications = [NSMutableArray array];
                                            if(laneItem.indications != nil) {

                                                if(laneItem.indications & MBLaneIndicationLeft) {
                                                    [indications addObject:@"left"];
                                                }
                                                if(laneItem.indications & MBLaneIndicationRight) {
                                                    [indications addObject:@"right"];
                                                }
                                                if(laneItem.indications & MBLaneIndicationUTurn) {
                                                    [indications addObject:@"uturn"];
                                                }
                                                if(laneItem.indications & MBLaneIndicationSharpLeft) {
                                                    [indications addObject:@"sharp left"];
                                                }
                                                if(laneItem.indications & MBLaneIndicationSharpRight) {
                                                    [indications addObject:@"sharp right"];
                                                }
                                                if(laneItem.indications & MBLaneIndicationSlightLeft) {
                                                    [indications addObject:@"slight left"];
                                                }
                                                if(laneItem.indications & MBLaneIndicationSlightRight) {
                                                    [indications addObject:@"slight right"];
                                                }
                                                if(laneItem.indications & MBLaneIndicationStraightAhead) {
                                                    [indications addObject:@"straight"];
                                                }

                                            }
                                            [lanesList addObject:@{
                                                @"valid": @YES,
                                                @"indications": indications
                                            }];
                                        }
                                        [intersectionDict setObject:lanesList forKey:@"lanes"];
                                    }
                                    [intersectionList addObject:intersectionDict];
                                }
                                [stepsDict setObject:intersectionList forKey:@"intersections"];
                            }
                            [stepsList addObject:stepsDict];
                        }
                    }
                    [legsDict setObject:stepsList forKey:@"steps"];
                    [legsDict setObject:@{
                        @"distance": leg.segmentDistances?leg.segmentDistances:@0,
                        @"duration": leg.expectedSegmentTravelTimes?leg.expectedSegmentTravelTimes:@0,
                        @"speed": leg.segmentSpeeds?leg.segmentSpeeds:@0,
                        //TODO: NOT FOUND
                        //@"congestion": leg.segmentCongestionLevels?.map { $0.description }
                        @"baseDuration": leg.segmentBaseDurations?leg.segmentBaseDurations:@0
//                         @"nodes": leg.
//                         @"maxspeed": leg.segmen
                    } forKey:@"annotation"];
                    [legList addObject: legsDict];
                }
                [data setObject:legList forKey:@"legs"];
            }
            NSMutableArray *coordinates = [NSMutableArray array];
            for (int z=0; z<route.directionsOptions.waypoints.count; z++) {
                MBWaypoint * waypoint = route.directionsOptions.waypoints[z];
                if (waypoint.eLoc!=nil) {
                    [coordinates addObject:waypoint.eLoc];
                }else{
                    [coordinates addObject:[NSMutableString stringWithFormat:@"%f,%f", waypoint.coordinate.longitude,waypoint.coordinate.latitude]];
                }
                }
            NSDictionary * routeOption = @{
               // @"deviceID": route.directionsOptions
               //                @"user": item.routeOptions.user
                @"profile": route.directionsOptions.profileIdentifier?route.directionsOptions.profileIdentifier:@"",
                @"resource":  route.directionsOptions.resourceIdentifier?route.directionsOptions.resourceIdentifier:@"",
                @"coordinates": coordinates,
                //TODO: NOT FOUND
                //@"alternatives": route.directionsOptions.,
               //                @"radiuses": item.routeOptions.rad
               //                @"bearings": item.routeOptions.
               //                @"language": item.routeOptions.lan
               //                @"lessverbose": item.routeOptions.less
                //TODO: CHECK FOR ENUM
                @"geometries": route.directionsOptions.shapeFormat?[self shapeFormatToString:route.directionsOptions.shapeFormat]:@"",
                @"overview": route.directionsOptions.routeShapeResolution?[self overViewToString:route.directionsOptions.routeShapeResolution]:@"",
                @"steps": route.directionsOptions.includesSteps?[NSNumber numberWithBool:route.directionsOptions.includesSteps]:@true,
               // @"annotations":route.directionsOptions.attributeOptions?[self attributionList:route.directionsOptions]: @"",
                //TODO: NOT FOUND
                //@"exclude": route.directionsOptions.roadClassesToAvoid.description,
            };
            [data setObject:routeOption forKey:@"routeOptions"];
            [routesList addObject:data];
        }


        NSDictionary *resultDict = @{@"code":@"OK",@"waypoints":wayPointList,@"routes":routesList};
        return [resultDict toJSONString];

    }

- (NSArray*) attributionList:(MBDirectionsOptions *) options {
    NSMutableArray *annotations = [NSMutableArray array];
        if([options attributeOptions] & MBAttributeCongestionLevel) {
            [annotations addObject: @"congestion"];
        }
        if(options.attributeOptions & MBAttributeNodes) {
            [annotations addObject: @"nodes"];
        }
    return annotations;
}


//convert array of coordinates into Geometry String
- (NSString *)encodeStringWithCoordinates:(NSArray *)coordinates
{
  NSMutableString *encodedString = [NSMutableString string];
  int val = 0;
  int value = 0;
  CLLocationCoordinate2D prevCoordinate = CLLocationCoordinate2DMake(0, 0);

  for (NSValue *coordinateValue in coordinates) {
    CLLocationCoordinate2D coordinate = [coordinateValue MKCoordinateValue];

    // Encode latitude
    val = round((coordinate.latitude - prevCoordinate.latitude) * 1e6);
    val = (val < 0) ? ~(val<<1) : (val <<1);
    while (val >= 0x20) {
      int value = (0x20|(val & 31)) + 63;
      [encodedString appendFormat:@"%c", value];
      val >>= 5;
    }
    [encodedString appendFormat:@"%c", val + 63];

    // Encode longitude
    val = round((coordinate.longitude - prevCoordinate.longitude) * 1e6);
    val = (val < 0) ? ~(val<<1) : (val <<1);
    while (val >= 0x20) {
      value = (0x20|(val & 31)) + 63;
      [encodedString appendFormat:@"%c", value];
      val >>= 5;
    }
    [encodedString appendFormat:@"%c", val + 63];

    prevCoordinate = coordinate;
  }

  return encodedString;
}

//// You call it with
//[... encodeStringWithCoordinates:@[
//                      [NSValue valueWithMKCoordinate:CLLocationCoordinate2DMake(38.5, -120.2)],
//                      [NSValue valueWithMKCoordinate:CLLocationCoordinate2DMake(40.7, -120.95)],
//                      [NSValue valueWithMKCoordinate:CLLocationCoordinate2DMake(43.252, -126.453)]
//                      ]



- (NSString*)shapeFormatToString:(MBRouteShapeFormat)mode{
    switch(mode) {
        case 0:
            return @"geojson";
        case 1:
            return @"polyline";
        case 2:
            return @"polyline6";
        default:
            [NSException raise:NSGenericException format:@"Unexpected MODE."];
    }
    return nil;
}

- (NSString*) annotationListToString: (NSArray*)attributions {
    return nil;
}

- (NSString*) overViewToString:(MBRouteShapeResolution)mode{
    switch(mode) {
        case 0:
            return @"false";
        case 1:
            return @"simplified";
        case 2:
            return @"full";
        default:
            [NSException raise:NSGenericException format:@"Unexpected MODE."];
    }
    return nil;
}


//typedef enum {
//  JSON = 0,         // explicitly indicate starting index
//  XML,
//  Atom,
//  RSS,
//
//  FormatTypeCount,  // keep track of the enum size automatically
//} FormatType;
//extern NSString *const FormatTypeName[FormatTypeCount];
//
//
//// In a source file
//NSString *const FormatTypeName[FormatTypeCount] = {
//  [JSON] = @"JSON",
//  [XML] = @"XML",
//  [Atom] = @"Atom",
//  [RSS] = @"RSS",
//};


@end
