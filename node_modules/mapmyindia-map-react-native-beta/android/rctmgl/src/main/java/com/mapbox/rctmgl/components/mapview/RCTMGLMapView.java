package com.mapbox.rctmgl.components.mapview;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Color;
import android.graphics.PointF;
import android.graphics.RectF;
import android.location.Location;
import android.os.Handler;


import androidx.annotation.NonNull;

import android.util.DisplayMetrics;
import android.util.Pair;
import android.view.Gravity;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.widget.FrameLayout;


import com.facebook.react.bridge.LifecycleEventListener;
import com.facebook.react.bridge.ReactContext;
import com.facebook.react.bridge.ReadableArray;
import com.facebook.react.bridge.ReadableMap;
import com.facebook.react.bridge.WritableArray;
import com.facebook.react.bridge.WritableMap;
import com.facebook.react.bridge.WritableNativeArray;
import com.facebook.react.bridge.WritableNativeMap;
import com.mapbox.android.gestures.MoveGestureDetector;
import com.mapbox.geojson.Feature;
import com.mapbox.geojson.FeatureCollection;
import com.mapbox.mapboxsdk.camera.CameraPosition;
import com.mapbox.mapboxsdk.camera.CameraUpdate;
import com.mapbox.mapboxsdk.geometry.LatLng;
import com.mapbox.mapboxsdk.geometry.VisibleRegion;
import com.mapbox.mapboxsdk.maps.MapView;
import com.mapbox.mapboxsdk.maps.MapboxMap;
import com.mapbox.mapboxsdk.maps.MapmyIndiaMapOptions;
import com.mapbox.mapboxsdk.maps.OnMapReadyCallback;
import com.mapbox.mapboxsdk.maps.UiSettings;
import com.mapbox.mapboxsdk.maps.style.OnStyleLoadListener;
import com.mapbox.mapboxsdk.maps.widgets.indoor.iface.IndoorListener;
import com.mapbox.mapboxsdk.style.expressions.Expression;
import com.mapbox.mapboxsdk.style.layers.Layer;
import com.mapbox.mapboxsdk.style.layers.Property;
import com.mapbox.rctmgl.R;
import com.mapbox.rctmgl.components.AbstractMapFeature;
import com.mapbox.rctmgl.components.annotation.RCTMGLPointAnnotation;
import com.mapbox.rctmgl.components.camera.RCTMGLCamera;
import com.mapbox.rctmgl.components.mapview.helpers.CameraChangeTracker;
import com.mapbox.rctmgl.components.styles.layers.RCTLayer;
import com.mapbox.rctmgl.components.styles.light.RCTMGLLight;
import com.mapbox.rctmgl.components.styles.sources.RCTMGLShapeSource;
import com.mapbox.rctmgl.components.styles.sources.RCTSource;
import com.mapbox.rctmgl.events.AndroidCallbackEvent;
import com.mapbox.rctmgl.events.IEvent;
import com.mapbox.rctmgl.events.MapChangeEvent;
import com.mapbox.rctmgl.events.MapClickEvent;
import com.mapbox.rctmgl.events.MapErrorEvent;
import com.mapbox.rctmgl.events.MapmyIndiaStyleLoadedEvent;
import com.mapbox.rctmgl.events.constants.EventTypes;
import com.mapbox.rctmgl.utils.BitmapUtils;
import com.mapbox.rctmgl.utils.GeoJSONUtils;
import com.mapbox.rctmgl.utils.GeoViewport;
import com.mapmyindia.sdk.plugin.annotation.OnSymbolClickListener;
import com.mapmyindia.sdk.plugin.annotation.OnSymbolDragListener;
import com.mapmyindia.sdk.plugin.annotation.Symbol;
import com.mapmyindia.sdk.plugin.annotation.SymbolManager;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;

import javax.annotation.Nullable;

import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.visibility;

/**
 * Created by nickitaliano on 8/18/17.
 */

@SuppressWarnings({"MissingPermission"})
public class RCTMGLMapView extends MapView implements OnMapReadyCallback, MapboxMap.OnMapClickListener,
        MapboxMap.OnMapLongClickListener, MapView.OnMapChangedListener {
    public static final String LOG_TAG = RCTMGLMapView.class.getSimpleName();

    private RCTMGLMapViewManager mManager;
    private Context mContext;
    private Handler mHandler;
    private LifecycleEventListener mLifeCycleListener;
    private boolean mPaused;
    private boolean mDestroyed;

    private RCTMGLCamera mCamera;
    private List<AbstractMapFeature> mFeatures;
    private List<AbstractMapFeature> mQueuedFeatures;
    private Map<String, RCTMGLPointAnnotation> mPointAnnotations;
    private Map<String, RCTSource> mSources;

    private CameraChangeTracker mCameraChangeTracker = new CameraChangeTracker();
    private List<Pair<Integer, ReadableArray>> mPreRenderMethods = new ArrayList<>();

    private MapboxMap mMap;

    private String mStyleURL;
    private String mapmyIndiaStyle;

    private Integer mPreferredFramesPerSecond;
    private boolean mLocalizeLabels;
    private Boolean mScrollEnabled;
    private Boolean mPitchEnabled;
    private Boolean mRotateEnabled;
    private Boolean mLayerControlEnabled;
    private Integer mLayerControlGravity;
    private int[] mLayerControlMargin;
    private Boolean mLogoEnabled;
    private Boolean mCompassEnabled;
    private ReadableMap mCompassViewMargins;
    private Boolean mZoomEnabled;

    private SymbolManager symbolManager;

    private long mActiveMarkerID = -1;

    private ReadableArray mInsets;

    private HashSet<String> mHandledMapChangedEvents = null;

    private ViewGroup mOffscreenAnnotationViewContainer = null;

    private boolean mAnnotationClicked = false;

    public RCTMGLMapView(Context context, RCTMGLMapViewManager manager, MapmyIndiaMapOptions options) {
        super(context, options);

        mContext = context;
        onCreate(null);
        onStart();
        onResume();
        getMapAsync(this);

        mManager = manager;

        mSources = new HashMap<>();
        mPointAnnotations = new HashMap<>();
        mQueuedFeatures = new ArrayList<>();
        mFeatures = new ArrayList<>();

        mHandler = new Handler();

        setLifecycleListeners();


        addOnMapChangedListener(this);
//        addOnCameraIsChangingListener(this);
//        addOnCameraDidChangeListener(this);
//        addOnDidFailLoadingMapListener(this);
//        addOnDidFinishLoadingMapListener(this);
//        addOnStyleImageMissingListener(this);

//        addOnWillStartRenderingFrameListener(this);
//        addOnDidFinishRenderingFrameListener(this);
//        addOnWillStartRenderingMapListener(this);
//        addOnDidFinishRenderingMapListener(this);
//        addOnDidFinishLoadingStyleListener(this);
    }

    @Override
    public void onResume() {
        super.onResume();
        mPaused = false;
    }

    @Override
    public void onPause() {
        super.onPause();
        mPaused = true;
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        mDestroyed = true;
    }

    public void enqueuePreRenderMapMethod(Integer methodID, @Nullable ReadableArray args) {
        mPreRenderMethods.add(new Pair<>(methodID, args));
    }

    public void addFeature(View childView, int childPosition) {
        AbstractMapFeature feature = null;

        if (childView instanceof RCTSource) {
            RCTSource source = (RCTSource) childView;
            mSources.put(source.getID(), source);
            feature = (AbstractMapFeature) childView;
        } else if (childView instanceof RCTMGLLight) {
            feature = (AbstractMapFeature) childView;
        } else if (childView instanceof RCTMGLPointAnnotation) {
            RCTMGLPointAnnotation annotation = (RCTMGLPointAnnotation) childView;
            mPointAnnotations.put(annotation.getID(), annotation);
            feature = (AbstractMapFeature) childView;
        } else if (childView instanceof RCTMGLCamera) {
            RCTMGLCamera camera = (RCTMGLCamera) childView;
            mCamera = camera;
            feature = (AbstractMapFeature) childView;
        } else if (childView instanceof RCTLayer) {
            feature = (RCTLayer) childView;
        } else if (childView instanceof ViewGroup) {
            ViewGroup children = (ViewGroup) childView;

            for (int i = 0; i < children.getChildCount(); i++) {
                addFeature(children.getChildAt(i), childPosition);
            }
        }

        if (feature != null) {
            if (mQueuedFeatures == null) {
                feature.addToMap(this);
                mFeatures.add(childPosition, feature);
            } else {
                mQueuedFeatures.add(childPosition, feature);
            }
        }
    }

    public void removeFeature(int childPosition) {
        AbstractMapFeature feature = features().get(childPosition);

        if (feature == null) {
            return;
        }

        if (feature instanceof RCTSource) {
            RCTSource source = (RCTSource) feature;
            mSources.remove(source.getID());
        } else if (feature instanceof RCTMGLPointAnnotation) {
            RCTMGLPointAnnotation annotation = (RCTMGLPointAnnotation) feature;

            if (annotation.getMapboxID() == mActiveMarkerID) {
                mActiveMarkerID = -1;
            }

            mPointAnnotations.remove(annotation.getID());
        }

        feature.removeFromMap(this);
        features().remove(feature);
    }

    private List<AbstractMapFeature> features() {
        if (mQueuedFeatures != null && mQueuedFeatures.size() > 0) {
            return mQueuedFeatures;
        } else {
            return mFeatures;
        }
    }

    public int getFeatureCount() {
        return features().size();
    }

    public AbstractMapFeature getFeatureAt(int i) {
        return features().get(i);
    }

    public synchronized void dispose() {
        if (mDestroyed) {
            return;
        }

        if (!layerWaiters.isEmpty()) {
            layerWaiters.clear();
        }

        ReactContext reactContext = (ReactContext) mContext;
        reactContext.removeLifecycleEventListener(mLifeCycleListener);

        if (!mPaused) {
            onPause();
        }

        onStop();
        onDestroy();
    }

    public VisibleRegion getVisibleRegion(LatLng center, double zoomLevel) {
        DisplayMetrics metrics = mContext.getResources().getDisplayMetrics();
        int[] contentPadding = mMap.getPadding();

        int mapWidth = (int) ((mMap.getWidth() * 0.75 - (contentPadding[0] + contentPadding[2]))
                / metrics.scaledDensity);
        int mapHeight = (int) ((mMap.getHeight() * 0.75 - (contentPadding[1] + contentPadding[3]))
                / metrics.scaledDensity);
        VisibleRegion region = GeoViewport.getRegion(center, (int) zoomLevel, mapWidth, mapHeight);
        return region;
    }

    public CameraPosition getCameraPosition() {
        return mMap.getCameraPosition();
    }

    public void animateCamera(CameraUpdate cameraUpdate, MapboxMap.CancelableCallback callback) {
        mMap.animateCamera(cameraUpdate, callback);
    }

    public void moveCamera(CameraUpdate cameraUpdate, MapboxMap.CancelableCallback callback) {
        mMap.moveCamera(cameraUpdate, callback);
    }

    public void moveCamera(CameraUpdate cameraUpdate) {
        mMap.moveCamera(cameraUpdate);
    }

    public void easeCamera(CameraUpdate cameraUpdate, int duration, MapboxMap.CancelableCallback callback) {
        mMap.easeCamera(cameraUpdate, duration, callback);
    }

    public void easeCamera(CameraUpdate cameraUpdate) {
        mMap.easeCamera(cameraUpdate);
    }

    public RCTMGLPointAnnotation getPointAnnotationByID(String annotationID) {
        if (annotationID == null) {
            return null;
        }

        for (String key : mPointAnnotations.keySet()) {
            RCTMGLPointAnnotation annotation = mPointAnnotations.get(key);

            if (annotation != null && annotationID.equals(annotation.getID())) {
                return annotation;
            }
        }

        return null;
    }

    public RCTMGLPointAnnotation getPointAnnotationByMarkerID(long markerID) {
        for (String key : mPointAnnotations.keySet()) {
            RCTMGLPointAnnotation annotation = mPointAnnotations.get(key);

            if (annotation != null && markerID == annotation.getMapboxID()) {
                return annotation;
            }
        }

        return null;
    }

    public MapboxMap getMapboxMap() {
        return mMap;
    }

    public SymbolManager getSymbolManager() {
        return symbolManager;
    }


    public interface FoundLayerCallback {
        public void found(Layer layer);
    }

    private Map<String, List<FoundLayerCallback>> layerWaiters = new HashMap<String, List<FoundLayerCallback>>();

    public void layerAdded(Layer layer) {
        String layerId = layer.getId();

        List<FoundLayerCallback> callbacks = layerWaiters.get(layerId);
        if (callbacks != null) {
            for (FoundLayerCallback callback : callbacks) {
                callback.found(layer);
            }
        }
        layerWaiters.remove(layerId);
    }

    public void waitForLayer(String layerID, FoundLayerCallback callback) {
        Layer layer = mMap.getLayer(layerID);
        if (layer != null) {
            callback.found(layer);
        } else {
            List<FoundLayerCallback> waiters = layerWaiters.get(layerID);
            if (waiters == null) {
                waiters = new ArrayList<FoundLayerCallback>();
                layerWaiters.put(layerID, waiters);
            }
            waiters.add(callback);
        }
    }


    @Override
    public void onMapReady(final MapboxMap mapboxMap) {
        mMap = mapboxMap;

        mapboxMap.addOnIndoorListener(new IndoorListener() {
            @Override
            public void showControl(final int i, final int i1, final int i2) {
                /*postDelayed(new Runnable() {
                    @Override
                    public void run() {
                        if(i>0||i1>0||i2>0){
                            ViewGroup.LayoutParams getLayoutParams =  mapboxMap.getUiSettings().getLayerControl().getChildAt(0).getLayoutParams();
                            getLayoutParams.height=200;
                            getLayoutParams.width=100;
                            mapboxMap.getUiSettings().getLayerControl().getChildAt(0).setLayoutParams(getLayoutParams);
                            mapboxMap.getUiSettings().getLayerControl().setMinimumHeight(100);
//            mapboxMap.getUiSettings().getLayerControl().invalidate();
                            mapboxMap.getUiSettings().getLayerControl().getChildAt(0).setBackgroundColor(Color.BLACK);
                        }
                        mapboxMap.getUiSettings().getLayerControl().requestLayout();
                    }
                },2000);*/
            }

            @Override
            public void hideControl() {

            }
        });
        MapmyIndiaStyleLoadedEvent event = new MapmyIndiaStyleLoadedEvent(this, mapboxMap.getMapmyIndiaAvailableStyles());
        mManager.handleEvent(event);
//        mMap.setStyleUrl(mStyleURL, new MapboxMap.OnStyleLoadedListener() {
//            @Override
//            public void onStyleLoaded(@NonNull String s) {
//                createSymbolManager();
//                setUpImage();
//                addQueuedFeatures();
//            }
//        });
        if(mapmyIndiaStyle != null) {
            mMap.setMapmyIndiaStyle(mapmyIndiaStyle, new OnStyleLoadListener() {
                @Override
                public void onError(String s) {

                }

                @Override
                public void onStyleLoaded() {
                    createSymbolManager();
                    setUpImage();
                    addQueuedFeatures();
                }
            });
        } else {
            createSymbolManager();
            setUpImage();
            addQueuedFeatures();
        }

        reflow();


        updatePreferredFramesPerSecond();
        updateInsets();
        updateUISettings();

        mMap.addOnCameraIdleListener(new MapboxMap.OnCameraIdleListener() {
            @Override
            public void onCameraIdle() {
                sendRegionDidChangeEvent();
            }
        });

        mMap.addOnCameraMoveStartedListener(new MapboxMap.OnCameraMoveStartedListener() {
            @Override
            public void onCameraMoveStarted(int reason) {
                mCameraChangeTracker.setReason(reason);
                handleMapChangedEvent(EventTypes.REGION_WILL_CHANGE);
            }
        });


        mMap.addOnMoveListener(new MapboxMap.OnMoveListener() {
            @Override
            public void onMoveBegin(MoveGestureDetector detector) {
                mCameraChangeTracker.setReason(CameraChangeTracker.USER_GESTURE);
                handleMapChangedEvent(EventTypes.REGION_WILL_CHANGE);
            }

            @Override
            public void onMove(MoveGestureDetector detector) {
                mCameraChangeTracker.setReason(CameraChangeTracker.USER_GESTURE);
                handleMapChangedEvent(EventTypes.REGION_IS_CHANGING);
            }

            @Override
            public void onMoveEnd(MoveGestureDetector detector) {
            }
        });
    }

    @Override
    public void onMapError(int i, String s) {
//        handleMapChangedEvent(EventTypes.DID_FAIL_LOADING_MAP);
        MapErrorEvent event = new MapErrorEvent(this, i, s);
        mManager.handleEvent(event);
    }

    public void reflow() {
        mHandler.post(new Runnable() {
            @Override
            public void run() {
                measure(View.MeasureSpec.makeMeasureSpec(getMeasuredWidth(), View.MeasureSpec.EXACTLY),
                        View.MeasureSpec.makeMeasureSpec(getMeasuredHeight(), View.MeasureSpec.EXACTLY));
                layout(getLeft(), getTop(), getRight(), getBottom());
            }
        });
    }

    public void createSymbolManager() {
        symbolManager = new SymbolManager(this, mMap);
        symbolManager.setIconAllowOverlap(true);
        symbolManager.addClickListener(new OnSymbolClickListener() {
            @Override
            public boolean onAnnotationClick(Symbol symbol) {
                onMarkerClick(symbol);
                return true;
            }
        });
        symbolManager.addDragListener(new OnSymbolDragListener() {
            @Override
            public void onAnnotationDragStarted(Symbol symbol) {
                mAnnotationClicked = true;
                final long selectedMarkerID = symbol.getId();
                RCTMGLPointAnnotation annotation = getPointAnnotationByMarkerID(selectedMarkerID);
                if (annotation != null) {
                    annotation.onDragStart();
                }
            }

            @Override
            // Left empty on purpose
            public void onAnnotationDrag(Symbol symbol) {

            }

            @Override
            public void onAnnotationDragFinished(Symbol symbol) {
                mAnnotationClicked = false;
                final long selectedMarkerID = symbol.getId();
                RCTMGLPointAnnotation annotation = getPointAnnotationByMarkerID(selectedMarkerID);
                if (annotation != null) {
                    annotation.onDragEnd();
                }
            }
        });
        mMap.addOnMapClickListener(this);
        mMap.addOnMapLongClickListener(this);
    }

    public void addQueuedFeatures() {
        if (mQueuedFeatures.size() > 0) {
            for (int i = 0; i < mQueuedFeatures.size(); i++) {
                AbstractMapFeature feature = mQueuedFeatures.get(i);
                feature.addToMap(this);
                mFeatures.add(feature);
            }
            mQueuedFeatures = null;
        }
    }

    @Override
    public boolean onTouchEvent(MotionEvent ev) {
        boolean result = super.onTouchEvent(ev);

        if (result && mScrollEnabled) {
            requestDisallowInterceptTouchEvent(true);
        }

        return result;
    }

    @Override
    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
        if (!mPaused) {
            super.onLayout(changed, left, top, right, bottom);
        }
    }

    @Override
    public void onMapClick(@NonNull LatLng point) {
        if (mAnnotationClicked) {
            mAnnotationClicked = false;
            return;
        }

        PointF screenPoint = mMap.getProjection().toScreenLocation(point);
        List<RCTSource> touchableSources = getAllTouchableSources();

        Map<String, Feature> hits = new HashMap<>();
        List<RCTSource> hitTouchableSources = new ArrayList<>();
        for (RCTSource touchableSource : touchableSources) {
            Map<String, Double> hitbox = touchableSource.getTouchHitbox();
            if (hitbox == null) {
                continue;
            }

            float halfWidth = hitbox.get("width").floatValue() / 2.0f;
            float halfHeight = hitbox.get("height").floatValue() / 2.0f;

            RectF hitboxF = new RectF();
            hitboxF.set(screenPoint.x - halfWidth, screenPoint.y - halfHeight, screenPoint.x + halfWidth,
                    screenPoint.y + halfHeight);

            List<Feature> features = mMap.queryRenderedFeatures(hitboxF, touchableSource.getLayerIDs());
            if (features.size() > 0) {
                hits.put(touchableSource.getID(), features.get(0));
                hitTouchableSources.add(touchableSource);
            }
        }

        if (hits.size() > 0) {
            RCTSource source = getTouchableSourceWithHighestZIndex(hitTouchableSources);
            if (source != null && source.hasPressListener()) {
                source.onPress(hits.get(source.getID()));
                return;
            }
        }

        MapClickEvent event = new MapClickEvent(this, point, screenPoint);
        mManager.handleEvent(event);

    }

    @Override
    public void onMapLongClick(@NonNull LatLng point) {
        if (mAnnotationClicked) {
            mAnnotationClicked = false;
            return;
        }
        PointF screenPoint = mMap.getProjection().toScreenLocation(point);
        MapClickEvent event = new MapClickEvent(this, point, screenPoint, EventTypes.MAP_LONG_CLICK);
        mManager.handleEvent(event);
    }

    public void onMarkerClick(@NonNull Symbol symbol) {
        mAnnotationClicked = true;
        final long selectedMarkerID = symbol.getId();

        RCTMGLPointAnnotation activeAnnotation = null;
        RCTMGLPointAnnotation nextActiveAnnotation = null;

        for (String key : mPointAnnotations.keySet()) {
            RCTMGLPointAnnotation annotation = mPointAnnotations.get(key);
            final long curMarkerID = annotation.getMapboxID();
            if (mActiveMarkerID == curMarkerID) {
                activeAnnotation = annotation;
            }
            if (selectedMarkerID == curMarkerID && mActiveMarkerID != curMarkerID) {
                nextActiveAnnotation = annotation;
            }
        }

        if (activeAnnotation != null) {
            deselectAnnotation(activeAnnotation);
        }

        if (nextActiveAnnotation != null) {
            selectAnnotation(nextActiveAnnotation);
        }

    }

    public void selectAnnotation(RCTMGLPointAnnotation annotation) {
        mActiveMarkerID = annotation.getMapboxID();
        annotation.onSelect(true);
    }

    public void deselectAnnotation(RCTMGLPointAnnotation annotation) {
        mActiveMarkerID = -1;
        annotation.onDeselect();
    }

    @Override
    public void onMapChanged(int i) {
        if (i == MapView.DID_FINISH_LOADING_STYLE) {
            System.out.println("DID_FINISH_LOADING_STYLE");
            handleMapChangedEvent(EventTypes.DID_FINISH_LOADING_STYLE);
        } else if (i == MapView.DID_FAIL_LOADING_MAP) {
            handleMapChangedEvent(EventTypes.DID_FAIL_LOADING_MAP);
        } else if (i == MapView.DID_FINISH_LOADING_MAP) {
            System.out.println("DID_FINISH_LOADING_MAP");
            handleMapChangedEvent(EventTypes.DID_FINISH_LOADING_MAP);
//            if(mFeatures != null && mFeatures.size() > 0) {
//                for(AbstractMapFeature feature: mFeatures) {
//                    feature.addToMap(this);
//                }
//            }
        } else if (i == MapView.WILL_START_RENDERING_FRAME) {
            handleMapChangedEvent(EventTypes.WILL_START_RENDERING_FRAME);
        } else if (i == MapView.DID_FINISH_RENDERING_FRAME) {
            handleMapChangedEvent(EventTypes.DID_FINISH_RENDERING_FRAME);
        } else if (i == MapView.DID_FINISH_RENDERING_FRAME_FULLY_RENDERED) {
            handleMapChangedEvent(EventTypes.DID_FINISH_RENDERING_FRAME_FULLY);
        } else if (i == MapView.WILL_START_RENDERING_MAP) {
            handleMapChangedEvent(EventTypes.WILL_START_RENDERING_MAP);
        } else if (i == MapView.DID_FINISH_RENDERING_MAP_FULLY_RENDERED) {
            for (Pair<Integer, ReadableArray> preRenderMethod : mPreRenderMethods) {
                Integer methodID = preRenderMethod.first;
                ReadableArray args = preRenderMethod.second;
                mManager.receiveCommand(this, methodID, args);
            }
            mPreRenderMethods.clear();
            handleMapChangedEvent(EventTypes.DID_FINISH_RENDERING_MAP_FULLY);
        } else if (i == MapView.DID_FINISH_RENDERING_MAP) {
            handleMapChangedEvent(EventTypes.DID_FINISH_RENDERING_MAP);
        } else if (i == MapView.REGION_IS_CHANGING) {
            handleMapChangedEvent(EventTypes.REGION_IS_CHANGING);
        } else if (i == MapView.REGION_DID_CHANGE) {
            mCameraChangeTracker.setIsAnimating(false);
        } else if (i == MapView.REGION_DID_CHANGE_ANIMATED) {
            mCameraChangeTracker.setIsAnimating(true);
        }
    }

    /*

    @Override
    public void onStyleImageMissing(@NonNull String id) {
        List<RCTMGLShapeSource> allShapeSources = getAllShapeSources();
        for (RCTMGLShapeSource shapeSource : allShapeSources) {
            if (shapeSource.addMissingImageToStyle(id)) {
                return;
            }
        }

    }
*/


    private float getDisplayDensity() {
        return mContext.getResources().getDisplayMetrics().density;
    }

    public void setReactStyleURL(String styleURL) {
        mStyleURL = styleURL;

        if (mMap != null) {
            removeAllSourcesFromMap();

            mMap.setStyle(styleURL, new MapboxMap.OnStyleLoadedListener() {
                @Override
                public void onStyleLoaded(@NonNull String s) {
                    addAllSourcesToMap();
                }
            });
        }
    }

    public void setReactMapmyIndiaStyle(String mapmyIndiaStyle) {
        this.mapmyIndiaStyle = mapmyIndiaStyle;
        if (mapmyIndiaStyle != null && mMap != null) {
            removeAllSourcesFromMap();
            mMap.setMapmyIndiaStyle(mapmyIndiaStyle, new OnStyleLoadListener() {
                @Override
                public void onError(String s) {

                }

                @Override
                public void onStyleLoaded() {
                    addAllSourcesToMap();
                }
            });
        }
    }

    public void setReactPreferredFramesPerSecond(Integer preferredFramesPerSecond) {
        mPreferredFramesPerSecond = preferredFramesPerSecond;
        updatePreferredFramesPerSecond();
    }

    public void setReactContentInset(ReadableArray array) {
        mInsets = array;
        updateInsets();
    }

    public void setLocalizeLabels(boolean localizeLabels) {
        mLocalizeLabels = localizeLabels;
    }

    public void setReactZoomEnabled(boolean zoomEnabled) {
        mZoomEnabled = zoomEnabled;
        updateUISettings();
    }

    public void setReactScrollEnabled(boolean scrollEnabled) {
        mScrollEnabled = scrollEnabled;
        updateUISettings();
    }

    public void setReactPitchEnabled(boolean pitchEnabled) {
        mPitchEnabled = pitchEnabled;
        updateUISettings();
    }

    public void setReactRotateEnabled(boolean rotateEnabled) {
        mRotateEnabled = rotateEnabled;
        updateUISettings();
    }

    public void setReactLogoEnabled(boolean logoEnabled) {
        mLogoEnabled = logoEnabled;
        updateUISettings();
    }

    public void setReactCompassEnabled(boolean compassEnabled) {
        mCompassEnabled = compassEnabled;
        updateUISettings();
    }

    public void setReactCompassViewMargins(ReadableMap compassViewMargins) {
        mCompassViewMargins = compassViewMargins;
        updateUISettings();
    }

    public void setReactLayerControlEnabled(boolean LayerControlEnabled) {
        mLayerControlEnabled = LayerControlEnabled;
        updateUISettings();
    }

    public void setReactLayerControlPosition(ReadableMap position) {
        if (position == null) {
            // reset from explicit to default
            if (mLayerControlGravity != null) {
                MapmyIndiaMapOptions defaultOptions = MapmyIndiaMapOptions.createFromAttributes(mContext, null);
                mLayerControlGravity = defaultOptions.getLayerControlGravity();
                mLayerControlMargin = Arrays.copyOf(defaultOptions.getLayerControlMargins(), 4);
                updateUISettings();
            }
            return;
        }
        mLayerControlGravity = Gravity.NO_GRAVITY;
        if (position.hasKey("left")) {
            mLayerControlGravity |= Gravity.START;
        }
        if (position.hasKey("right")) {
            mLayerControlGravity |= Gravity.END;
        }
        if (position.hasKey("top")) {
            mLayerControlGravity |= Gravity.TOP;
        }
        if (position.hasKey("bottom")) {
            mLayerControlGravity |= Gravity.BOTTOM;
        }
        float density = getDisplayDensity();
        mLayerControlMargin = new int[]{
                position.hasKey("left") ? (int) density * position.getInt("left") : 0,
                position.hasKey("top") ? (int) density * position.getInt("top") : 0,
                position.hasKey("right") ? (int) density * position.getInt("right") : 0,
                position.hasKey("bottom") ? (int) density * position.getInt("bottom") : 0
        };
        updateUISettings();
    }

    public void queryRenderedFeaturesAtPoint(String callbackID, PointF point, Expression filter,
                                             List<String> layerIDs) {
        List<Feature> features = mMap.queryRenderedFeatures(point, filter,
                layerIDs.toArray(new String[layerIDs.size()]));

        WritableMap payload = new WritableNativeMap();
        payload.putString("data", FeatureCollection.fromFeatures(features).toJson());

        AndroidCallbackEvent event = new AndroidCallbackEvent(this, callbackID, payload);
        mManager.handleEvent(event);
    }

    public void getZoom(String callbackID) {
        CameraPosition position = mMap.getCameraPosition();

        WritableMap payload = new WritableNativeMap();
        payload.putDouble("zoom", position.zoom);

        AndroidCallbackEvent event = new AndroidCallbackEvent(this, callbackID, payload);
        mManager.handleEvent(event);
    }

    public void queryRenderedFeaturesInRect(String callbackID, RectF rect, Expression filter, List<String> layerIDs) {
        List<Feature> features = mMap.queryRenderedFeatures(rect, filter,
                layerIDs.toArray(new String[layerIDs.size()]));

        WritableMap payload = new WritableNativeMap();
        payload.putString("data", FeatureCollection.fromFeatures(features).toJson());

        AndroidCallbackEvent event = new AndroidCallbackEvent(this, callbackID, payload);
        mManager.handleEvent(event);
    }

    public void getVisibleBounds(String callbackID) {
        VisibleRegion region = mMap.getProjection().getVisibleRegion();

        WritableMap payload = new WritableNativeMap();
        payload.putArray("visibleBounds", GeoJSONUtils.fromLatLngBounds(region.latLngBounds));

        AndroidCallbackEvent event = new AndroidCallbackEvent(this, callbackID, payload);
        mManager.handleEvent(event);
    }

    public void getPointInView(String callbackID, LatLng mapCoordinate) {

        PointF pointInView = mMap.getProjection().toScreenLocation(mapCoordinate);
        WritableMap payload = new WritableNativeMap();

        WritableArray array = new WritableNativeArray();
        array.pushDouble(pointInView.x);
        array.pushDouble(pointInView.y);
        payload.putArray("pointInView", array);

        AndroidCallbackEvent event = new AndroidCallbackEvent(this, callbackID, payload);
        mManager.handleEvent(event);
    }

    public void getCoordinateFromView(String callbackID, PointF pointInView) {
        float density = getDisplayDensity();
        pointInView.x *= density;
        pointInView.y *= density;

        LatLng mapCoordinate = mMap.getProjection().fromScreenLocation(pointInView);
        WritableMap payload = new WritableNativeMap();

        WritableArray array = new WritableNativeArray();
        array.pushDouble(mapCoordinate.getLongitude());
        array.pushDouble(mapCoordinate.getLatitude());
        payload.putArray("coordinateFromView", array);

        AndroidCallbackEvent event = new AndroidCallbackEvent(this, callbackID, payload);
        mManager.handleEvent(event);
    }

    public void takeSnap(final String callbackID, final boolean writeToDisk) {

        if (mMap == null) {
            throw new Error("takeSnap should only be called after the map has rendered");
        }

        mMap.snapshot(new MapboxMap.SnapshotReadyCallback() {
            @Override
            public void onSnapshotReady(Bitmap snapshot) {
                WritableMap payload = new WritableNativeMap();
                String uri = writeToDisk ? BitmapUtils.createTempFile(mContext, snapshot)
                        : BitmapUtils.createBase64(snapshot);
                payload.putString("uri", uri);

                AndroidCallbackEvent event = new AndroidCallbackEvent(RCTMGLMapView.this, callbackID, payload);
                mManager.handleEvent(event);
            }
        });
    }

    public void getCenter(String callbackID) {
        LatLng center = mMap.getCameraPosition().target;

        WritableArray array = new WritableNativeArray();
        array.pushDouble(center.getLongitude());
        array.pushDouble(center.getLatitude());
        WritableMap payload = new WritableNativeMap();
        payload.putArray("center", array);

        AndroidCallbackEvent event = new AndroidCallbackEvent(this, callbackID, payload);
        mManager.handleEvent(event);
    }

    public void showLayerControl() {
        View LayerControlView = findViewById(R.id.floor_controller);
        LayerControlView.callOnClick();
    }

    public void setSourceVisibility(final boolean visible, @NonNull final String sourceId, @Nullable final String sourceLayerId) {
        if (mMap == null) {
            return;
        }

        List<Layer> layers = mMap.getLayers();
        for (Layer layer : layers) {
            LayerSourceInfo layerSourceInfo = new LayerSourceInfo(layer);
            if (layerSourceInfo.sourceId.equals(sourceId) && (sourceLayerId == null
                    || sourceLayerId.equals(layerSourceInfo.sourceLayerId))) {
                layer.setProperties(visibility(visible ? Property.VISIBLE : Property.NONE));
            }

        }
    }

    public void init() {
        // Required for rendering properly in Android Oreo
        getViewTreeObserver().dispatchOnGlobalLayout();
    }

    public boolean isDestroyed() {
        return mDestroyed;
    }

    private void updateUISettings() {
        if (mMap == null) {
            return;
        }

        UiSettings uiSettings = mMap.getUiSettings();

        if (mScrollEnabled != null && uiSettings.isScrollGesturesEnabled() != mScrollEnabled) {
            uiSettings.setScrollGesturesEnabled(mScrollEnabled);
            if (!mScrollEnabled) {
                mMap.getGesturesManager().getMoveGestureDetector().interrupt();
            }
        }

        if (mPitchEnabled != null && uiSettings.isTiltGesturesEnabled() != mPitchEnabled) {
            uiSettings.setTiltGesturesEnabled(mPitchEnabled);
        }

        if (mRotateEnabled != null && uiSettings.isRotateGesturesEnabled() != mRotateEnabled) {
            uiSettings.setRotateGesturesEnabled(mRotateEnabled);
            if (!mRotateEnabled) {
                mMap.getGesturesManager().getRotateGestureDetector().interrupt();
            }
        }

        if (mLayerControlEnabled != null && uiSettings.isLayerControlEnabled() != mLayerControlEnabled) {
            uiSettings.setLayerControlEnabled(mLayerControlEnabled);
        }

        if (mLayerControlGravity != null && uiSettings.getLayerControlGravity() != mLayerControlGravity) {
            uiSettings.setLayerControlGravity(mLayerControlGravity);
        }

        if (mLayerControlMargin != null &&
                (uiSettings.getLayerControlMarginLeft() != mLayerControlMargin[0] ||
                        uiSettings.getLayerControlMarginTop() != mLayerControlMargin[1] ||
                        uiSettings.getLayerControlMarginRight() != mLayerControlMargin[2] ||
                        uiSettings.getLayerControlMarginBottom() != mLayerControlMargin[3]
                )
        ) {
            uiSettings.setLayerControlMargins(
                    mLayerControlMargin[0],
                    mLayerControlMargin[1],
                    mLayerControlMargin[2],
                    mLayerControlMargin[3]
            );
        }

        if (mLogoEnabled != null && uiSettings.isLogoEnabled() != mLogoEnabled) {
            uiSettings.setLogoEnabled(mLogoEnabled);
        }

        if (mCompassEnabled != null && uiSettings.isCompassEnabled() != mCompassEnabled) {
            uiSettings.setCompassEnabled(mCompassEnabled);
        }

        if (mCompassViewMargins != null && uiSettings.isCompassEnabled()) {
            int pixelDensity = (int) getResources().getDisplayMetrics().density;

            int xMargin = mCompassViewMargins.getInt("x") * pixelDensity;
            int yMargin = mCompassViewMargins.getInt("y") * pixelDensity;
            uiSettings.setCompassMargins(xMargin, yMargin, xMargin, yMargin);
        }

        if (mZoomEnabled != null && uiSettings.isZoomGesturesEnabled() != mZoomEnabled) {
            uiSettings.setZoomGesturesEnabled(mZoomEnabled);
            if (!mZoomEnabled) {
                mMap.getGesturesManager().getStandardScaleGestureDetector().interrupt();
            }
        }
    }

    private void updatePreferredFramesPerSecond() {
        if (mPreferredFramesPerSecond == null) {
            return;
        }
//        setMaximumFps(mPreferredFramesPerSecond);
    }

    private void updateInsets() {
        if (mMap == null || mInsets == null) {
            return;
        }

        final DisplayMetrics metrics = mContext.getResources().getDisplayMetrics();
        int top = 0, right = 0, bottom = 0, left = 0;

        if (mInsets.size() == 4) {
            top = mInsets.getInt(0);
            right = mInsets.getInt(1);
            bottom = mInsets.getInt(2);
            left = mInsets.getInt(3);
        } else if (mInsets.size() == 2) {
            top = mInsets.getInt(0);
            right = mInsets.getInt(1);
            bottom = top;
            left = right;
        } else if (mInsets.size() == 1) {
            top = mInsets.getInt(0);
            right = top;
            bottom = top;
            left = top;
        }

        mMap.setPadding(Float.valueOf(left * metrics.scaledDensity).intValue(),
                Float.valueOf(top * metrics.scaledDensity).intValue(),
                Float.valueOf(right * metrics.scaledDensity).intValue(),
                Float.valueOf(bottom * metrics.scaledDensity).intValue());
    }

    private void setLifecycleListeners() {
        final ReactContext reactContext = (ReactContext) mContext;

        mLifeCycleListener = new LifecycleEventListener() {
            @Override
            public void onHostResume() {
                onResume();
            }

            @Override
            public void onHostPause() {
                onPause();
            }

            @Override
            public void onHostDestroy() {
                dispose();
            }
        };

        reactContext.addLifecycleEventListener(mLifeCycleListener);
    }

    private WritableMap makeRegionPayload(Boolean isAnimated) {
        CameraPosition position = mMap.getCameraPosition();
        LatLng latLng = new LatLng(position.target.getLatitude(), position.target.getLongitude());

        WritableMap properties = new WritableNativeMap();

        properties.putDouble("zoomLevel", position.zoom);
        properties.putDouble("heading", position.bearing);
        properties.putDouble("pitch", position.tilt);
        properties.putBoolean("animated",
                (null == isAnimated) ? mCameraChangeTracker.isAnimated() : isAnimated.booleanValue());
        properties.putBoolean("isUserInteraction", mCameraChangeTracker.isUserInteraction());

        VisibleRegion visibleRegion = mMap.getProjection().getVisibleRegion();
        properties.putArray("visibleBounds", GeoJSONUtils.fromLatLngBounds(visibleRegion.latLngBounds));

        return GeoJSONUtils.toPointFeature(latLng, properties);
    }

    public void sendRegionChangeEvent(boolean isAnimated) {
        IEvent event = new MapChangeEvent(this, EventTypes.REGION_DID_CHANGE,
                makeRegionPayload(new Boolean(isAnimated)));

        mManager.handleEvent(event);
        mCameraChangeTracker.setReason(CameraChangeTracker.EMPTY);
    }

    private void removeAllSourcesFromMap() {
        if (mSources.size() == 0) {
            return;
        }
        for (String key : mSources.keySet()) {
            RCTSource source = mSources.get(key);
            source.removeFromMap(this);
        }
    }

    private void addAllSourcesToMap() {
        if (mSources.size() == 0) {
            return;
        }
        for (String key : mSources.keySet()) {
            RCTSource source = mSources.get(key);
            source.addToMap(this);
        }
    }

    private List<RCTSource> getAllTouchableSources() {
        List<RCTSource> sources = new ArrayList<>();

        for (String key : mSources.keySet()) {
            RCTSource source = mSources.get(key);
            if (source != null && source.hasPressListener()) {
                sources.add(source);
            }
        }

        return sources;
    }

    private List<RCTMGLShapeSource> getAllShapeSources() {
        List<RCTMGLShapeSource> shapeSources = new ArrayList<>();

        for (String key : mSources.keySet()) {
            RCTSource source = mSources.get(key);

            if (source instanceof RCTMGLShapeSource) {
                shapeSources.add((RCTMGLShapeSource) source);
            }
        }

        return shapeSources;
    }

    private RCTSource getTouchableSourceWithHighestZIndex(List<RCTSource> sources) {
        if (sources == null || sources.size() == 0) {
            return null;
        }

        if (sources.size() == 1) {
            return sources.get(0);
        }

        Map<String, RCTSource> layerToSourceMap = new HashMap<>();
        for (RCTSource source : sources) {
            String[] layerIDs = source.getLayerIDs();

            for (String layerID : layerIDs) {
                layerToSourceMap.put(layerID, source);
            }
        }

        List<Layer> mapboxLayers = mMap.getLayers();
        for (int i = mapboxLayers.size() - 1; i >= 0; i--) {
            Layer mapboxLayer = mapboxLayers.get(i);

            String layerID = mapboxLayer.getId();
            if (layerToSourceMap.containsKey(layerID)) {
                return layerToSourceMap.get(layerID);
            }
        }

        return null;
    }

    private boolean hasSetCenterCoordinate() {
        CameraPosition cameraPosition = mMap.getCameraPosition();
        LatLng center = cameraPosition.target;
        return center.getLatitude() != 0.0 && center.getLongitude() != 0.0;
    }

    private double getMapRotation() {
        CameraPosition cameraPosition = mMap.getCameraPosition();
        return cameraPosition.bearing;
    }

    public void sendRegionDidChangeEvent() {

        handleMapChangedEvent(EventTypes.REGION_DID_CHANGE);
        mCameraChangeTracker.setReason(mCameraChangeTracker.EMPTY);
    }

    private void handleMapChangedEvent(String eventType) {
        if (!canHandleEvent(eventType))
            return;

        IEvent event;

        switch (eventType) {
            case EventTypes.REGION_WILL_CHANGE:
            case EventTypes.REGION_DID_CHANGE:
            case EventTypes.REGION_IS_CHANGING:
                event = new MapChangeEvent(this, eventType, makeRegionPayload(null));
                break;
            default:
                event = new MapChangeEvent(this, eventType);
        }

        mManager.handleEvent(event);
    }

    private boolean canHandleEvent(String event) {
        return mHandledMapChangedEvents == null || mHandledMapChangedEvents.contains(event);
    }

    public void setHandledMapChangedEvents(ArrayList<String> eventsWhiteList) {
        this.mHandledMapChangedEvents = new HashSet<>(eventsWhiteList);
    }

    private void sendUserLocationUpdateEvent(Location location) {
        if (location == null) {
            return;
        }
        IEvent event = new MapChangeEvent(this, EventTypes.USER_LOCATION_UPDATED, makeLocationChangePayload(location));
        mManager.handleEvent(event);
    }

    private WritableMap makeLocationChangePayload(Location location) {

        WritableMap positionProperties = new WritableNativeMap();
        WritableMap coords = new WritableNativeMap();

        coords.putDouble("longitude", location.getLongitude());
        coords.putDouble("latitude", location.getLatitude());
        coords.putDouble("altitude", location.getAltitude());
        coords.putDouble("accuracy", location.getAccuracy());
        coords.putDouble("heading", location.getBearing());
        coords.putDouble("speed", location.getSpeed());

        positionProperties.putMap("coords", coords);
        positionProperties.putDouble("timestamp", location.getTime());
        return positionProperties;
    }

    /**
     * Adds the marker image to the map for use as a SymbolLayer icon
     */
    private void setUpImage() {
        mMap.addImage("MARKER_IMAGE_ID", BitmapFactory.decodeResource(
                this.getResources(), R.drawable.red_marker)
        );
    }

    /**
     * PointAnnotations are rendered to a canvas, but react native Image component is
     * implemented on top of Fresco, and fresco will not load images when their view is
     * not attached to the window. So we'll have an offscreen view where we add those views
     * so they can rendered full to canvas.
     */
    public ViewGroup offscreenAnnotationViewContainer() {
        if (mOffscreenAnnotationViewContainer == null) {
            mOffscreenAnnotationViewContainer = new FrameLayout(getContext());
            FrameLayout.LayoutParams flParams = new FrameLayout.LayoutParams(0, 0);
            flParams.setMargins(-10000, -10000, -10000, -10000);
            mOffscreenAnnotationViewContainer.setLayoutParams(flParams);
            addView(mOffscreenAnnotationViewContainer);
        }
        return mOffscreenAnnotationViewContainer;
    }


}
