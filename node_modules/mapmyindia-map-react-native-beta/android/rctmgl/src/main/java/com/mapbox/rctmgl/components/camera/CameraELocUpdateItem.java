package com.mapbox.rctmgl.components.camera;


import com.mapbox.mapboxsdk.camera.CameraUpdateFactory;
import com.mapbox.mapboxsdk.constants.MapboxConstants;
import com.mapbox.mapboxsdk.maps.MapboxMap;
import com.mapbox.rctmgl.components.camera.constants.CameraMode;

import java.lang.ref.WeakReference;
import java.util.List;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.RunnableFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

/**
 * Created by Saksham on 27-01-2021
 */

public class CameraELocUpdateItem implements RunnableFuture<Void> {

    private CameraELocPosition cameraELocPosition;
    private List<String> mELocList;
    private int mBoundsPaddingLeft = 0;
    private int mBoundsPaddingRight = 0;
    private int mBoundsPaddingBottom = 0;
    private int mBoundsPaddingTop = 0;
    private int mDuration;
    private MapboxMap.CancelableCallback mCallback;
    private int mCameraMode;

    private boolean isCameraActionFinished;
    private boolean isCameraActionCancelled;

    private WeakReference<MapboxMap> mMap;

    public CameraELocUpdateItem(MapboxMap map, CameraELocPosition cameraELocPosition, int duration, MapboxMap.CancelableCallback callback, @CameraMode.Mode int cameraMode) {
        this.cameraELocPosition = cameraELocPosition;
        this.mDuration = duration;
        this.mCallback = callback;
        this.mCameraMode = cameraMode;
        mMap = new WeakReference<>(map);
    }

    public CameraELocUpdateItem(MapboxMap map, List<String> eLocList, int paddingLeft, int paddingRight, int paddingBottom, int paddingTop, int duration, MapboxMap.CancelableCallback callback, @CameraMode.Mode int cameraMode) {
        this.mELocList = eLocList;
        this.mBoundsPaddingBottom = paddingBottom;
        this.mBoundsPaddingLeft = paddingLeft;
        this.mBoundsPaddingRight = paddingRight;
        this.mBoundsPaddingTop = paddingTop;
        this.mDuration = duration;
        this.mCallback = callback;
        this.mCameraMode = cameraMode;
        mMap = new WeakReference<>(map);
    }

    @Override
    public void run() {
        final MapboxMap.CancelableCallback callback = new MapboxMap.CancelableCallback() {
            @Override
            public void onCancel() {
                if(cameraELocPosition != null) {
                    if(cameraELocPosition.bearing >= 0) {
                        mMap.get().moveCamera(CameraUpdateFactory.bearingTo(cameraELocPosition.bearing));
                    }
                    if(cameraELocPosition.tilt >= 0) {
                        mMap.get().moveCamera(CameraUpdateFactory.tiltTo(cameraELocPosition.tilt));
                    }
                }
                handleCallbackResponse(true);
            }

            @Override
            public void onFinish() {
                if(cameraELocPosition != null) {
                    if(cameraELocPosition.bearing >= 0) {
                        mMap.get().moveCamera(CameraUpdateFactory.bearingTo(cameraELocPosition.bearing));
                    }
                    if(cameraELocPosition.tilt >= 0) {
                        mMap.get().moveCamera(CameraUpdateFactory.tiltTo(cameraELocPosition.tilt));
                    }
                }
                handleCallbackResponse(false);
            }
        };

        MapboxMap map = mMap.get();
        if (map == null) {
            isCameraActionCancelled = true;
            return;
        }

        // animateCamera / easeCamera only allows positive duration
        if (mDuration == 0 || mCameraMode == CameraMode.NONE) {
            if(cameraELocPosition != null) {
                if(cameraELocPosition.zoom == -1) {
                    map.moveCamera(cameraELocPosition.target, map.getCameraPosition().zoom, callback);
                } else {
                    map.moveCamera(cameraELocPosition.target, cameraELocPosition.zoom, callback);
                }
            } else {
                map.moveCamera(mELocList, mBoundsPaddingLeft, mBoundsPaddingTop, mBoundsPaddingRight, mBoundsPaddingBottom, callback);
            }
            return;
        }

        // On iOS a duration of -1 means default or dynamic duration (based on flight-path length)
        // On Android we can fallback to Mapbox's default duration as there is no such API
        int duration = mDuration < 0 ? MapboxConstants.ANIMATION_DURATION : mDuration;

        if (mCameraMode == CameraMode.FLIGHT) {
            if(cameraELocPosition != null) {
                if(cameraELocPosition.zoom == -1) {
                    map.animateCamera(cameraELocPosition.target, map.getCameraPosition().zoom, duration, callback);
                } else {
                    map.animateCamera(cameraELocPosition.target, cameraELocPosition.zoom, duration, callback);
                }
            } else {
                map.animateCamera(mELocList, mBoundsPaddingLeft, mBoundsPaddingTop, mBoundsPaddingRight, mBoundsPaddingBottom, duration, callback);
            }
        } else if (mCameraMode == CameraMode.EASE) {
            if(cameraELocPosition != null) {
                if(cameraELocPosition.zoom == -1) {
                    map.easeCamera(cameraELocPosition.target, map.getCameraPosition().zoom, duration, callback);
                } else {
                    map.easeCamera(cameraELocPosition.target, cameraELocPosition.zoom, duration, callback);
                }
            } else {
                map.easeCamera(mELocList, mBoundsPaddingLeft, mBoundsPaddingTop, mBoundsPaddingRight, mBoundsPaddingBottom, duration, callback);
            }
        }
    }

    @Override
    public boolean cancel(boolean mayInterruptIfRunning) {
        return false;
    }

    @Override
    public boolean isCancelled() {
        return isCameraActionCancelled;
    }

    @Override
    public boolean isDone() {
        return isCameraActionFinished;
    }

    @Override
    public Void get() throws ExecutionException, InterruptedException {
        return null;
    }

    @Override
    public Void get(long timeout, TimeUnit unit) throws ExecutionException, InterruptedException, TimeoutException {
        return null;
    }


    private void handleCallbackResponse(boolean isCancel) {
        if (mCallback == null) {
            return;
        }

        isCameraActionCancelled = isCancel;
        isCameraActionFinished = !isCancel;

        if (isCancel) {
            mCallback.onCancel();
        } else {
            mCallback.onFinish();
        }
    }
}
