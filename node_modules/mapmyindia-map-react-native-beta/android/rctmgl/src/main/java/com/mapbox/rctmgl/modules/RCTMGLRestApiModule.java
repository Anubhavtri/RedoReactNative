package com.mapbox.rctmgl.modules;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import com.facebook.react.bridge.Promise;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactMethod;
import com.facebook.react.bridge.ReadableArray;
import com.facebook.react.bridge.ReadableMap;
import com.facebook.react.common.MapBuilder;
import com.facebook.react.module.annotations.ReactModule;
import com.google.gson.Gson;
import com.mapbox.geojson.Point;
import com.mmi.services.api.OnResponseCallback;
import com.mmi.services.api.PlaceResponse;
import com.mmi.services.api.alongroute.MapmyIndiaPOIAlongRoute;
import com.mmi.services.api.alongroute.POICriteria;
import com.mmi.services.api.alongroute.models.POIAlongRouteResponse;
import com.mmi.services.api.autosuggest.AutoSuggestCriteria;
import com.mmi.services.api.autosuggest.MapmyIndiaAutoSuggest;
import com.mmi.services.api.autosuggest.model.AutoSuggestAtlasResponse;
import com.mmi.services.api.autosuggest.model.ELocation;
import com.mmi.services.api.directions.DirectionsCriteria;
import com.mmi.services.api.directions.MapmyIndiaDirections;
import com.mmi.services.api.directions.models.DirectionsResponse;
import com.mmi.services.api.distance.MapmyIndiaDistanceMatrix;
import com.mmi.services.api.distance.models.DistanceResponse;
import com.mmi.services.api.eloc.MapmyIndiaELoc;
import com.mmi.services.api.feedback.MapmyIndiaFeedback;
import com.mmi.services.api.geocoding.GeoCodeResponse;
import com.mmi.services.api.geocoding.GeoCodingCriteria;
import com.mmi.services.api.geocoding.MapmyIndiaGeoCoding;
import com.mmi.services.api.nearby.MapmyIndiaNearby;
import com.mmi.services.api.nearby.NearbyCriteria;
import com.mmi.services.api.nearby.model.NearbyAtlasResponse;
import com.mmi.services.api.placedetail.MapmyIndiaPlaceDetail;
import com.mmi.services.api.placedetail.model.PlaceDetailResponse;
import com.mmi.services.api.reversegeocode.MapmyIndiaReverseGeoCode;
import com.mmi.services.api.session.SessionCriteria;
import com.mmi.services.api.session.devicelist.MapmyIndiaClusterLinkedDevices;
import com.mmi.services.api.session.devicelist.MapmyIndiaClusterLinkedDevicesManager;
import com.mmi.services.api.session.devicelist.model.Device;
import com.mmi.services.api.session.endsession.MapmyIndiaEndSession;
import com.mmi.services.api.session.endsession.MapmyIndiaEndSessionManager;
import com.mmi.services.api.session.removedevice.MapmyIndiaDeleteClusterLinkedDevice;
import com.mmi.services.api.session.removedevice.MapmyIndiaDeleteClusterLinkedDeviceManager;
import com.mmi.services.api.textsearch.MapmyIndiaTextSearch;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

import retrofit2.Call;
import retrofit2.Callback;
import retrofit2.Response;

@ReactModule(name = RCTMGLRestApiModule.REACT_CLASS)
public class RCTMGLRestApiModule extends ReactContextBaseJavaModule {

    public RCTMGLRestApiModule(ReactApplicationContext reactApplicationContext) {
        super(reactApplicationContext);
    }

    static final String REACT_CLASS = "RCTMGLRestApiModule";
    static  final String REQUIRED_CODE ="REQUIRED PARAMETER";

    @Nullable
    @Override
    public Map<String, Object> getConstants() {

        Map<String, Object> autosuggestConstants = new HashMap<>();
        autosuggestConstants.put("POD_CITY", AutoSuggestCriteria.POD_CITY);
        autosuggestConstants.put("POD_DISTRICT", AutoSuggestCriteria.POD_DISTRICT);
        autosuggestConstants.put("POD_LOCALITY", AutoSuggestCriteria.POD_LOCALITY);
        autosuggestConstants.put("POD_STATE", AutoSuggestCriteria.POD_STATE);
        autosuggestConstants.put("POD_SUB_DISTRICT", AutoSuggestCriteria.POD_SUB_DISTRICT);
        autosuggestConstants.put("POD_SUB_LOCALITY", AutoSuggestCriteria.POD_SUB_LOCALITY);
        autosuggestConstants.put("POD_SUB_SUB_LOCALITY", AutoSuggestCriteria.POD_SUB_SUB_LOCALITY);
        autosuggestConstants.put("POD_VILLAGE", AutoSuggestCriteria.POD_VILLAGE);

        Map<String, Object> geoCodeConstants = new HashMap<>();
        geoCodeConstants.put("BIAS_DEFAULT", GeoCodingCriteria.BIAS_DEFAULT);
        geoCodeConstants.put("BIAS_RURAL", GeoCodingCriteria.BIAS_RURAL);
        geoCodeConstants.put("BIAS_URBAN", GeoCodingCriteria.BIAS_URBAN);

        geoCodeConstants.put("POD_CITY", GeoCodingCriteria.POD_CITY);
        geoCodeConstants.put("POD_DISTRICT", GeoCodingCriteria.POD_DISTRICT);
        geoCodeConstants.put("POD_HOUSE_NAME", GeoCodingCriteria.POD_HOUSE_NAME);
        geoCodeConstants.put("POD_HOUSE_NUMBER", GeoCodingCriteria.POD_HOUSE_NUMBER);
        geoCodeConstants.put("POD_LOCALITY", GeoCodingCriteria.POD_LOCALITY);
        geoCodeConstants.put("POD_PINCODE", GeoCodingCriteria.POD_PINCODE);
        geoCodeConstants.put("POD_POINT_OF_INTEREST", GeoCodingCriteria.POD_POINT_OF_INTEREST);
        geoCodeConstants.put("POD_STATE", GeoCodingCriteria.POD_STATE);
        geoCodeConstants.put("POD_STREET", GeoCodingCriteria.POD_STREET);
        geoCodeConstants.put("POD_SUB_DISTRICT", GeoCodingCriteria.POD_SUB_DISTRICT);
        geoCodeConstants.put("POD_SUB_LOCALITY", GeoCodingCriteria.POD_SUB_LOCALITY);
        geoCodeConstants.put("POD_SUB_SUB_LOCALITY", GeoCodingCriteria.POD_SUB_SUB_LOCALITY);
        geoCodeConstants.put("POD_VILLAGE", GeoCodingCriteria.POD_VILLAGE);

        Map<String, Object> nearbyConstants = new HashMap<>();
        nearbyConstants.put("DISTANCE_ASCENDING", NearbyCriteria.DISTANCE_ASCENDING);
        nearbyConstants.put("DISTANCE_DESCENDING", NearbyCriteria.DISTANCE_DESCENDING);
        nearbyConstants.put("NAME_ASCENDING", NearbyCriteria.NAME_ASCENDING);
        nearbyConstants.put("NAME_DESCENDING", NearbyCriteria.NAME_DESCENDING);

        nearbyConstants.put("DISTANCE", NearbyCriteria.DISTANCE);
        nearbyConstants.put("IMPORTANCE", NearbyCriteria.IMPORTANCE);

        Map<String, Object> directionConstants = new HashMap<>();
        directionConstants.put("EXCLUDE_TUNNEL", DirectionsCriteria.EXCLUDE_TUNNEL);
        directionConstants.put("EXCLUDE_RESTRICTED", DirectionsCriteria.EXCLUDE_RESTRICTED);
        directionConstants.put("EXCLUDE_MOTORWAY", DirectionsCriteria.EXCLUDE_MOTORWAY);
        directionConstants.put("EXCLUDE_FERRY", DirectionsCriteria.EXCLUDE_FERRY);
        directionConstants.put("EXCLUDE_TOLL", DirectionsCriteria.EXCLUDE_TOLL);

        directionConstants.put("ANNOTATION_SPEED", DirectionsCriteria.ANNOTATION_SPEED);
        directionConstants.put("ANNOTATION_NODES", DirectionsCriteria.ANNOTATION_NODES);
        directionConstants.put("ANNOTATION_MAXSPEED", DirectionsCriteria.ANNOTATION_MAXSPEED);
        directionConstants.put("ANNOTATION_DURATION", DirectionsCriteria.ANNOTATION_DURATION);
        directionConstants.put("ANNOTATION_DISTANCE", DirectionsCriteria.ANNOTATION_DISTANCE);
        directionConstants.put("ANNOTATION_BASE_DURATION", DirectionsCriteria.ANNOTATION_BASE_DURATION);
        directionConstants.put("ANNOTATION_CONGESTION", DirectionsCriteria.ANNOTATION_CONGESTION);
        directionConstants.put("ANNOTATION_SPEED_LIMIT", DirectionsCriteria.ANNOTATION_SPEED_LIMIT);

        directionConstants.put("OVERVIEW_FALSE", DirectionsCriteria.OVERVIEW_FALSE);
        directionConstants.put("OVERVIEW_SIMPLIFIED", DirectionsCriteria.OVERVIEW_SIMPLIFIED);
        directionConstants.put("OVERVIEW_FULL", DirectionsCriteria.OVERVIEW_FULL);

        directionConstants.put("PROFILE_WALKING", DirectionsCriteria.PROFILE_WALKING);
        directionConstants.put("PROFILE_TRUCKING", DirectionsCriteria.PROFILE_TRUCKING);
        directionConstants.put("PROFILE_BIKING", DirectionsCriteria.PROFILE_BIKING);
        directionConstants.put("PROFILE_DRIVING", DirectionsCriteria.PROFILE_DRIVING);

        directionConstants.put("RESOURCE_ROUTE_TRAFFIC", DirectionsCriteria.RESOURCE_ROUTE_TRAFFIC);
        directionConstants.put("RESOURCE_ROUTE", DirectionsCriteria.RESOURCE_ROUTE);
        directionConstants.put("RESOURCE_ROUTE_ETA", DirectionsCriteria.RESOURCE_ROUTE_ETA);
        directionConstants.put("RESOURCE_DISTANCE", DirectionsCriteria.RESOURCE_DISTANCE);
        directionConstants.put("RESOURCE_DISTANCE_ETA", DirectionsCriteria.RESOURCE_DISTANCE_ETA);
        directionConstants.put("RESOURCE_DISTANCE_TRAFFIC", DirectionsCriteria.RESOURCE_DISTANCE_TRAFFIC);

        directionConstants.put("APPROACH_CURB", DirectionsCriteria.APPROACH_CURB);
        directionConstants.put("APPROACH_UNRESTRICTED", DirectionsCriteria.APPROACH_UNRESTRICTED);

        directionConstants.put("DESTINATION_ANY", DirectionsCriteria.DESTINATION_ANY);
        directionConstants.put("DESTINATION_LAST", DirectionsCriteria.DESTINATION_LAST);

        directionConstants.put("GEOMETRY_POLYLINE", DirectionsCriteria.GEOMETRY_POLYLINE);
        directionConstants.put("GEOMETRY_POLYLINE6", DirectionsCriteria.GEOMETRY_POLYLINE6);

        directionConstants.put("IMPERIAL", DirectionsCriteria.IMPERIAL);
        directionConstants.put("METRIC", DirectionsCriteria.METRIC);

        directionConstants.put("SOURCE_ANY", DirectionsCriteria.SOURCE_ANY);
        directionConstants.put("SOURCE_FIRST", DirectionsCriteria.SOURCE_FIRST);


        Map<String, Object> poiConstants = new HashMap<>();
        directionConstants.put("GEOMETRY_BASE64", POICriteria.GEOMETRY_BASE64);
        directionConstants.put("GEOMETRY_POLYLINE5",POICriteria.GEOMETRY_POLYLINE5);
        directionConstants.put("GEOMETRY_POLYLINE6", POICriteria.GEOMETRY_POLYLINE6);

        Map<String, Object> sessionConstants = new HashMap<>();
        sessionConstants.put("SESSION_TYPE_GLOBAL", SessionCriteria.SESSION_TYPE_GLOBAL);
        sessionConstants.put("SESSION_TYPE_NAVIGATION",SessionCriteria.SESSION_TYPE_NAVIGATION);

        return MapBuilder.<String, Object>builder()
                .put("AutoSuggestCriteria", autosuggestConstants)
                .put("GeoCodingCriteria", geoCodeConstants)
                .put("NearbyCriteria", nearbyConstants)
                .put("DirectionsCriteria", directionConstants)
                .put("POICriteria",poiConstants)
                .put("SessionCriteria",sessionConstants)
                .build();
    }

    @NonNull
    @Override
    public String getName() {
        return REACT_CLASS;
    }

    @ReactMethod
    public void reverseGeocode(ReadableMap readableMap, final Promise promise) {
        double latitude;
        if (readableMap.hasKey("latitude")) {
            latitude = readableMap.getDouble("latitude");
        } else {
            promise.reject(REQUIRED_CODE,"Please provide latitude parameter");
            //failureCallback.invoke("Please provide latitude parameter");
            return;
        }
        double longitude;
        if (readableMap.hasKey("longitude")) {
            longitude = readableMap.getDouble("longitude");
        } else {
            promise.reject(REQUIRED_CODE,"PPlease provide longitude parameter");
            //failureCallback.invoke("Please provide longitude parameter");
            return;
        }
        if (latitude < 0 || longitude < 0) {
            promise.reject(REQUIRED_CODE,"Please provide valid location");
            //failureCallback.invoke("Please provide valid location");
            return;
        }
        MapmyIndiaReverseGeoCode.builder()
                .setLocation(latitude, longitude)
                .build().enqueueCall(new Callback<PlaceResponse>() {
            @Override
            public void onResponse(Call<PlaceResponse> call, Response<PlaceResponse> response) {

                if (response.code() == 200) {


                    if (response.body() != null) {

                        PlaceResponse placeResponse = response.body();
                         promise.resolve(new Gson().toJson(placeResponse));
                        //successCallback.invoke(response.code(), new Gson().toJson(placeResponse));

                    } else {
                        promise.resolve(null);
                    }

                } else {
                    promise.reject(String.valueOf(response.code()),response.message());
                    //successCallback.invoke(response.code(), null);
                }
            }

            @Override
            public void onFailure(Call<PlaceResponse> call, Throwable t) {
                promise.reject("0",t.getLocalizedMessage());
                //failureCallback.invoke(t.getMessage());
            }
        });

    }

    @ReactMethod
    public void autoSuggest(ReadableMap readableMap, final Promise promise) {

        MapmyIndiaAutoSuggest.Builder mBuilder = MapmyIndiaAutoSuggest.builder();
        if (readableMap.hasKey("query") && !readableMap.isNull("query")) {
            mBuilder.query(readableMap.getString("query"));
        } else {
            promise.reject(REQUIRED_CODE,"Please provide query parameter");
            //failureCallback.invoke("Please provide query parameter");
            return;
        }

        if (readableMap.hasKey("filter")) {
            mBuilder.filter(readableMap.getString("filter"));
        }

        if (readableMap.hasKey("pod")) {
            mBuilder.pod(readableMap.getString("pod"));
        }
        if (readableMap.hasKey("location") && !readableMap.isNull("location")) {
            ReadableMap location = readableMap.getMap("location");
            if (location.hasKey("latitude") && location.hasKey("longitude")) {
                mBuilder.setLocation(location.getDouble("latitude"), location.getDouble("longitude"));
            }
        }
        if (readableMap.hasKey("tokenizeAddress")) {
            boolean tokenizeAddress = readableMap.getBoolean("tokenizeAddress");
            if (tokenizeAddress){
                mBuilder.tokenizeAddress(true);
            }
        }
        if (readableMap.hasKey("zoom")) {
            mBuilder.zoom(readableMap.getDouble("zoom"));
        }
        mBuilder.build().enqueueCall(new Callback<AutoSuggestAtlasResponse>() {
            @Override
            public void onResponse(Call<AutoSuggestAtlasResponse> call, Response<AutoSuggestAtlasResponse> response) {
                if (response.code() == 200) {


                    if (response.body() != null) {

                        AutoSuggestAtlasResponse autoSuggestAtlasResponse = response.body();
                      promise.resolve(parseAutoSuggestResponse(autoSuggestAtlasResponse));
                        //successCallback.invoke(response.code(), parseAutoSuggestResponse(autoSuggestAtlasResponse));


                    } else {
                        promise.resolve(null);
                       // successCallback.invoke(response.code(), null);
                    }

                } else {
                    promise.reject(String.valueOf(response.code()),response.message());
                    //successCallback.invoke(response.code(), null);
                }


            }

            @Override
            public void onFailure(Call<AutoSuggestAtlasResponse> call, Throwable t) {
                //failureCallback.invoke(t.getMessage());
                promise.reject("0",t.getLocalizedMessage());

            }
        });

    }


    //parsing manual because lat/lng coming as x/y
    private String parseAutoSuggestResponse(AutoSuggestAtlasResponse response){

        ArrayList suggestedLocations = new ArrayList();
       if (response.getSuggestedLocations()!=null){
           for (int i=0;i<response.getSuggestedLocations().size();i++){


               ELocation item = response.getSuggestedLocations().get(i);
               HashMap<String,Object> addressTokens = new HashMap<>();
               if (item.addressTokens!=null){
                   addressTokens.put("poi",item.addressTokens.poi);
                   addressTokens.put("city",item.addressTokens.city);
                   addressTokens.put("district",item.addressTokens.district);
                   addressTokens.put("houseName",item.addressTokens.houseName);
                   addressTokens.put("houseNumber",item.addressTokens.houseNumber);
                   addressTokens.put("locality",item.addressTokens.locality);
                   addressTokens.put("pincode",item.addressTokens.pincode);
                   addressTokens.put("state",item.addressTokens.state);
                   addressTokens.put("street",item.addressTokens.street);
                   addressTokens.put("subDistrict",item.addressTokens.subDistrict);
                   addressTokens.put("subLocality",item.addressTokens.subLocality);
                   addressTokens.put("subSubLocality",item.addressTokens.subSubLocality);
                   addressTokens.put("village",item.addressTokens.village);
               }

               HashMap<String,Object> data = new HashMap<>();
               ArrayList keywords= new ArrayList();
               if (item.keywords!=null&&item.keywords.size()>0){
                   for (String keyword:item.keywords){
                       keywords.add(keyword);
                   }
               }

               data.put("elc",item.poiId);
               data.put("placeName",item.placeName);
               data.put("addr",item.placeAddress);
               data.put("longitude",item.longitude);
               data.put("latitude",item.latitude);
               data.put("type",item.type);
               data.put("entryLatitude",item.entryLatitude);
               data.put("entryLongitude",item.entryLongitude);
               data.put("orderIndex",item.orderIndex);
               data.put("keywords",keywords);
               data.put("typeX",item.typeX);
               data.put("addressTokens",addressTokens);

               suggestedLocations.add(data);
           } }
        HashMap<String,Object> result = new HashMap<>();
        result.put("suggestedLocations",suggestedLocations);
        return  new Gson().toJson(result);
    }


    @ReactMethod
    public void geocode(ReadableMap readableMap, final Promise promise) {
        MapmyIndiaGeoCoding.Builder mBuilder = MapmyIndiaGeoCoding.builder();
        if (readableMap.hasKey("address") && !readableMap.isNull("address")) {
            mBuilder.setAddress(readableMap.getString("address"));
        } else {
            promise.reject(REQUIRED_CODE,"please provide address parameter");
            //failureCallback.invoke("please provide address parameter");
            return;
        }
        if (readableMap.hasKey("bias")) {
            mBuilder.bias(readableMap.getInt("bias"));
        }
        if (readableMap.hasKey("bound")) {
            mBuilder.bound(readableMap.getString("bound"));
        }
        if (readableMap.hasKey("itemCount")) {
            mBuilder.itemCount(readableMap.getInt("itemCount"));
        }
        if (readableMap.hasKey("podFilter")) {
            mBuilder.podFilter(readableMap.getString("podFilter"));
        }
        mBuilder.build().enqueueCall(new Callback<GeoCodeResponse>() {
            @Override
            public void onResponse(Call<GeoCodeResponse> call, Response<GeoCodeResponse> response) {

                if (response.code() == 200) {


                    if (response.body() != null) {

                        GeoCodeResponse geoCodeResponse = response.body();
                        promise.resolve(new Gson().toJson(geoCodeResponse));
                        //successCallback.invoke(response.code(), new Gson().toJson(geoCodeResponse));


                    } else {
                        promise.resolve(null);
                        //successCallback.invoke(response.code(), null);
                    }

                } else {
                    promise.reject(String.valueOf(response.code()),response.message());
                    //successCallback.invoke(response.code(), null);
                }
            }

            @Override
            public void onFailure(Call<GeoCodeResponse> call, Throwable t) {
                //failureCallback.invoke(t.getMessage());
                promise.reject("0",t.getLocalizedMessage());
            }
        });
    }

    @ReactMethod
    public void textSearch(ReadableMap readableMap, final Promise promise) {
        MapmyIndiaTextSearch.Builder mBuilder = MapmyIndiaTextSearch.builder();
        if (readableMap.hasKey("query") && !readableMap.isNull("query")) {
            mBuilder.query(readableMap.getString("query"));
        } else {
            promise.reject(REQUIRED_CODE,"please provide query parameter");
            //failureCallback.invoke("please provide query parameter");
            return;
        }
        if (readableMap.hasKey("bridge")) {
            mBuilder.bridge(readableMap.getBoolean("bridge"));
        }
        if (readableMap.hasKey("explain")) {
            mBuilder.explain(readableMap.getBoolean("explain"));
        }
        if (readableMap.hasKey("filter")) {
            mBuilder.filter(readableMap.getString("filter"));
        }

        if (readableMap.hasKey("location")) {
            if (readableMap.hasKey("latitude") && readableMap.hasKey("longitude")) {
                mBuilder.setLocation(readableMap.getDouble("latitude"), readableMap.getDouble("longitude"));
            }
        }

        if (readableMap.hasKey("username")) {
            mBuilder.username(readableMap.getString("username"));
        }
        mBuilder.build().enqueueCall(new Callback<AutoSuggestAtlasResponse>() {
            @Override
            public void onResponse(Call<AutoSuggestAtlasResponse> call, Response<AutoSuggestAtlasResponse> response) {
                if (response.code() == 200) {


                    if (response.body() != null) {

                        AutoSuggestAtlasResponse autoSuggestAtlasResponse = response.body();
                        promise.resolve(new Gson().toJson(autoSuggestAtlasResponse));
                       // successCallback.invoke(response.code(), new Gson().toJson(autoSuggestAtlasResponse));


                    } else {
                        promise.resolve(null);
                        //successCallback.invoke(response.code(), null);
                    }

                } else {
                    //successCallback.invoke(response.code(), null);
                    promise.reject(String.valueOf(response.code()),response.message());
                }
            }

            @Override
            public void onFailure(Call<AutoSuggestAtlasResponse> call, Throwable t) {
                //failureCallback.invoke(t.getMessage());
                promise.reject("0",t.getLocalizedMessage());
            }
        });
    }

    @ReactMethod
    public void placeDetail(ReadableMap readableMap, final Promise promise) {
        MapmyIndiaPlaceDetail.Builder mBuilder = MapmyIndiaPlaceDetail.builder();
        if (readableMap.hasKey("eLoc") && !readableMap.isNull("eLoc")) {
            //mBuilder.setELoc();
            mBuilder.eLoc(readableMap.getString("eLoc"));
        } else {
            promise.reject(REQUIRED_CODE,"Please provide eLoc parameter");
            //failureCallback.invoke("Please provide eLoc parameter");
            return;
        }
        mBuilder.build().enqueueCall(new Callback<PlaceDetailResponse>() {
            @Override
            public void onResponse(Call<PlaceDetailResponse> call, Response<PlaceDetailResponse> response) {
                if (response.code() == 200) {

                    if (response.body() != null) {
                        PlaceDetailResponse placeDetailResponse = response.body();
                        promise.resolve(new Gson().toJson(placeDetailResponse));
                        //successCallback.invoke(response.code(), new Gson().toJson(placeDetailResponse));


                    } else {
                        promise.resolve(null);
                        //successCallback.invoke(response.code(), null);
                    }

                } else {
                    promise.reject(String.valueOf(response.code()),response.message());
                   // successCallback.invoke(response.code(), null);
                }
            }

            @Override
            public void onFailure(Call<PlaceDetailResponse> call, Throwable t) {
                //failureCallback.invoke(t.getMessage());
                promise.reject("0",t.getLocalizedMessage());
            }
        });
    }


    @ReactMethod
    public void placeDetailLegacy(ReadableMap readableMap, final Promise promise) {
        MapmyIndiaELoc.Builder mBuilder = MapmyIndiaELoc.builder();
        if (readableMap.hasKey("eLoc") && !readableMap.isNull("eLoc")) {
            mBuilder.setELoc(readableMap.getString("eLoc"));
        } else {
            promise.reject(REQUIRED_CODE,"Please provide eLoc parameter");
            //failureCallback.invoke("Please provide eLoc parameter");
            return;
        }
        mBuilder.build().enqueueCall(new Callback<PlaceResponse>() {
            @Override
            public void onResponse(Call<PlaceResponse> call, Response<PlaceResponse> response) {

                if (response.code() == 200) {


                    if (response.body() != null) {

                        PlaceResponse placeResponse = response.body();
                          promise.resolve(new Gson().toJson(placeResponse));
                       // successCallback.invoke(response.code(), new Gson().toJson(placeResponse));


                    } else {
                        promise.resolve(null);
                        //successCallback.invoke(response.code(), null);
                    }

                } else {
                    //successCallback.invoke(response.code(), null);
                    promise.reject(String.valueOf(response.code()),response.message());
                }

            }

            @Override
            public void onFailure(Call<PlaceResponse> call, Throwable t) {
                //failureCallback.invoke(t.getMessage());
                promise.reject("0",t.getLocalizedMessage());
            }
        });
    }

    @ReactMethod
    public void  POIAlongRoute(ReadableMap readableMap, final  Promise promise){
        MapmyIndiaPOIAlongRoute.Builder mBuilder = MapmyIndiaPOIAlongRoute.builder();
        if (readableMap.hasKey("category") && !readableMap.isNull("category")) {
            mBuilder.category(readableMap.getString("category"));
        } else {
            promise.reject(REQUIRED_CODE,"Please provide category parameter");
            //failureCallback.invoke("Please provide category parameter");
            return;
        }

        if (readableMap.hasKey("path") && !readableMap.isNull("path")) {
            mBuilder.path(readableMap.getString("path"));
        } else {
            promise.reject(REQUIRED_CODE,"Please provide path parameter");
            //failureCallback.invoke("Please provide path parameter");
            return;
        }
        if (readableMap.hasKey("buffer")) {
            mBuilder.buffer(readableMap.getInt("buffer"));
        }

        if (readableMap.hasKey("geometries")) {
            mBuilder.geometries(readableMap.getString("geometries"));
        }
        if (readableMap.hasKey("page")) {
            mBuilder.page(readableMap.getInt("page"));
        }
        if (readableMap.hasKey("sort")) {
            mBuilder.sort(readableMap.getBoolean("sort"));
        }

        mBuilder.build().enqueueCall(new Callback<POIAlongRouteResponse>() {
            @Override
            public void onResponse(Call<POIAlongRouteResponse> call, Response<POIAlongRouteResponse> response) {
                if (response.code() == 200) {


                    if (response.body() != null) {

                        POIAlongRouteResponse poiAlongRouteResponse = response.body();
                       promise.resolve(new Gson().toJson(poiAlongRouteResponse));
                        //successCallback.invoke(response.code(), new Gson().toJson(poiAlongRouteResponse));


                    } else {
                        promise.resolve(null);
                        //successCallback.invoke(response.code(), null);
                    }

                } else {
                    promise.reject(String.valueOf(response.code()),response.message());
                    //successCallback.invoke(response.code(), null);
                }
            }

            @Override
            public void onFailure(Call<POIAlongRouteResponse> call, Throwable t) {
                //failureCallback.invoke(t.getMessage());
                promise.reject("0",t.getLocalizedMessage());
            }
        });

    }

    @ReactMethod
    public void nearby(ReadableMap readableMap, final Promise promise) {
        MapmyIndiaNearby.Builder mBuilder = MapmyIndiaNearby.builder();
        if (readableMap.hasKey("keyword") && !readableMap.isNull("keyword")) {
            mBuilder.keyword(readableMap.getString("keyword"));
        } else {
            promise.reject(REQUIRED_CODE,"Please provide keyword parameter");
            //failureCallback.invoke("Please provide keyword parameter");
            return;
        }
        if (readableMap.hasKey("location") && !readableMap.isNull("location")) {
            String location = readableMap.getString("location");
            if (location.contains(",")){
                String[] locationArray = location.split(",");
                mBuilder.setLocation(Double.parseDouble(locationArray[0]), Double.parseDouble(locationArray[1]));
            }else {
                mBuilder.setLocation(location);
            }
        } else {
            promise.reject(REQUIRED_CODE,"Please provide location parameter");
            //failureCallback.invoke("Please provide location parameter");
            return;
        }
        if (readableMap.hasKey("bounds")) {
            mBuilder.bounds(readableMap.getString("bounds"));
        }
        if (readableMap.hasKey("filter")) {
            mBuilder.filter(readableMap.getString("filter"));
        }
        if (readableMap.hasKey("page")) {
            mBuilder.page(readableMap.getInt("page"));
        }
        if (readableMap.hasKey("pod")) {
            mBuilder.pod(readableMap.getString("pod"));
        }
        if (readableMap.hasKey("radius")) {
            mBuilder.radius(readableMap.getInt("radius"));
        }
        if (readableMap.hasKey("searchBy")) {
            mBuilder.searchBy(readableMap.getString("searchBy"));
        }
        if (readableMap.hasKey("sortBy")) {
            mBuilder.sortBy(readableMap.getString("sortBy"));
        }

        mBuilder.build().enqueueCall(new Callback<NearbyAtlasResponse>() {
            @Override
            public void onResponse(Call<NearbyAtlasResponse> call, Response<NearbyAtlasResponse> response) {
                if (response.code() == 200) {


                    if (response.body() != null) {

                        NearbyAtlasResponse nearbyAtlasResponse = response.body();
                        promise.resolve(new Gson().toJson(nearbyAtlasResponse));
                        //successCallback.invoke(response.code(), new Gson().toJson(nearbyAtlasResponse));


                    } else {
                        promise.resolve(null);
                        //successCallback.invoke(response.code(), null);
                    }

                } else {
                    promise.reject(String.valueOf(response.code()),response.message());
                    //successCallback.invoke(response.code(), null);
                }
            }

            @Override
            public void onFailure(Call<NearbyAtlasResponse> call, Throwable t) {
               // failureCallback.invoke(t.getMessage());
                promise.reject("0",t.getLocalizedMessage());
            }
        });
    }

    @ReactMethod
    public void direction(ReadableMap readableMap, final Promise promise) {
        MapmyIndiaDirections.Builder mBuilder = MapmyIndiaDirections.builder();
        if (readableMap.hasKey("origin")) {
            String origin = readableMap.getString("origin");
            if (origin.contains(",")){
                String [] location= origin.split(",");
                mBuilder.origin(Point.fromLngLat(Double.parseDouble(location[0]), Double.parseDouble(location[1])));
            }else {
                mBuilder.origin(origin);
            }
        } else {
            promise.reject(REQUIRED_CODE,"Please provide origin parameter");
            //failureCallback.invoke("Please provide origin parameter");
            return;
        }
        if (readableMap.hasKey("destination")) {
            String destination = readableMap.getString("destination");
            if (destination.contains(",")){
                String [] location= destination.split(",");
                mBuilder.destination(Point.fromLngLat(Double.parseDouble(location[0]), Double.parseDouble(location[1])));
            }else {
                mBuilder.destination(destination);
            }
        } else {
            promise.reject(REQUIRED_CODE,"Please provide destination parameter");
            //failureCallback.invoke("Please provide destination parameter");
            return;
        }
        if (readableMap.hasKey("waypoints") && !readableMap.isNull("waypoints")) {
            ReadableArray waypointsArray = readableMap.getArray("waypoints");
            for (int i = 0; i < waypointsArray.size(); i++) {

                String wayPoint = waypointsArray.getString(i);
                if (wayPoint.contains(",")){
                    String[] location = wayPoint.split(";");
                    mBuilder.addWaypoint(Point.fromLngLat(Double.parseDouble(location[0]), Double.parseDouble(location[0])));
                }else {
                    mBuilder.addWaypoint(wayPoint);
                }
            }
        }
        if (readableMap.hasKey("excludes")) {
            ReadableArray excludesArray = readableMap.getArray("excludes");
            String[] excludes = new String[excludesArray.size()];
            for (int i = 0; i < excludesArray.size(); i++) {
                excludes[i] = excludesArray.getString(i);
            }
            mBuilder.excludes(excludes);
        }
        if (readableMap.hasKey("annotations")) {
            ReadableArray annotationsArray = readableMap.getArray("annotations");
            String[] annotations = new String[annotationsArray.size()];
            for (int i = 0; i < annotationsArray.size(); i++) {
                annotations[i] = annotationsArray.getString(i);
            }
            mBuilder.annotations(annotations);
        }
        if (readableMap.hasKey("overview")) {
            mBuilder.overview(readableMap.getString("overview"));
        }
        if (readableMap.hasKey("steps")) {
            mBuilder.steps(readableMap.getBoolean("steps"));
        }
        if (readableMap.hasKey("alternatives")) {
            mBuilder.alternatives(readableMap.getBoolean("alternatives"));
        }
        if (readableMap.hasKey("approaches")) {
            ReadableArray approachesArray = readableMap.getArray("approaches");
            String[] approaches = new String[approachesArray.size()];
            for (int i = 0; i < approachesArray.size(); i++) {
                approaches[i] = approachesArray.getString(i);
            }
            mBuilder.addApproaches(approaches);
        }
        if (readableMap.hasKey("bearing")) {
            ReadableMap bearing = readableMap.getMap("bearing");
            if (bearing.hasKey("angle") && bearing.hasKey("tolerance")) {
                mBuilder.addBearing(bearing.getDouble("angle"), bearing.getDouble("tolerance"));
            }
        }
        if (readableMap.hasKey("waypointIndices")) {
            ReadableArray waypointIndicesArray = readableMap.getArray("waypointIndices");
            Integer[] waypointIndices = new Integer[waypointIndicesArray.size()];
            for (int i = 0; i < waypointIndicesArray.size(); i++) {
                waypointIndices[i] = waypointIndicesArray.getInt(i);
            }
            mBuilder.addWaypointIndices(waypointIndices);
        }
        if (readableMap.hasKey("waypointNames")) {
            ReadableArray waypointNamesArray = readableMap.getArray("waypointNames");
            String[] waypointNames = new String[waypointNamesArray.size()];
            for (int i = 0; i < waypointNamesArray.size(); i++) {
                waypointNames[i] = waypointNamesArray.getString(i);
            }
            mBuilder.addWaypointNames(waypointNames);
        }
        if (readableMap.hasKey("waypointTargets")) {
            ReadableArray waypointTargetsArray = readableMap.getArray("waypointTargets");
            Point[] waypointTargets = new Point[waypointTargetsArray.size()];
            for (int i = 0; i < waypointTargetsArray.size(); i++) {
                ReadableMap waypointTargetsMap = waypointTargetsArray.getMap(i);
                if (waypointTargetsMap.hasKey("latitude") && waypointTargetsMap.hasKey("longitude")) {
                    waypointTargets[i] = Point.fromLngLat(waypointTargetsMap.getDouble("longitude"), waypointTargetsMap.getDouble("longitude"));
                }
            }
            mBuilder.addWaypointTargets(waypointTargets);
        }
        if (readableMap.hasKey("bannerInstructions")) {
            mBuilder.bannerInstructions(readableMap.getBoolean("bannerInstructions"));
        }
        if (readableMap.hasKey("geometries")) {
            mBuilder.geometries(readableMap.getString("geometries"));
        }
        if (readableMap.hasKey("isSort")) {
            mBuilder.isSort(readableMap.getBoolean("isSort"));
        }
        if (readableMap.hasKey("lessVerbose")) {
            mBuilder.lessVerbose(readableMap.getBoolean("lessVerbose"));
        }
        if (readableMap.hasKey("profile")) {
            mBuilder.profile(readableMap.getString("profile"));
        }
        if (readableMap.hasKey("radiuses")) {
            ReadableArray radiusesArray = readableMap.getArray("radiuses");
            double[] radiuses = new double[radiusesArray.size()];
            for (int i = 0; i < radiusesArray.size(); i++) {
                radiuses[i] = radiusesArray.getDouble(i);
            }
            mBuilder.radiuses(radiuses);
        }
        if (readableMap.hasKey("resource")) {
            mBuilder.resource(readableMap.getString("resource"));
        }
        if (readableMap.hasKey("routeRefresh")) {
            mBuilder.routeRefresh(readableMap.getBoolean("routeRefresh"));
        }
        if (readableMap.hasKey("deviceId")) {
            mBuilder.deviceId(readableMap.getString("deviceId"));
        }
        if (readableMap.hasKey("roundaboutExits")) {
            mBuilder.roundaboutExits(readableMap.getBoolean("roundaboutExits"));
        }
        if (readableMap.hasKey("sessionId")) {
            mBuilder.sessionId(readableMap.getString("sessionId"));
        }
        if (readableMap.hasKey("voiceInstructions")) {
            mBuilder.voiceInstructions(readableMap.getBoolean("voiceInstructions"));
        }
        if (readableMap.hasKey("voiceUnits")) {
            mBuilder.voiceUnits(readableMap.getString("voiceUnits"));
        }
        mBuilder.build().enqueueCall(new Callback<DirectionsResponse>() {
            @Override
            public void onResponse(Call<DirectionsResponse> call, Response<DirectionsResponse> response) {
                if (response.code() == 200) {
                    if (response.body() != null) {
                        DirectionsResponse directionsResponse = response.body();
                        promise.resolve(directionsResponse.toJson());
                        ///successCallback.invoke(response.code(), directionsResponse.toJson());
                    } else {
                        promise.resolve(null);
                    }
                } else {
                    promise.reject(String.valueOf(response.code()), response.message());
                }
            }

            @Override
            public void onFailure(Call<DirectionsResponse> call, Throwable t) {
                //failureCallback.invoke(t.getMessage());
                promise.reject("0",t.getLocalizedMessage());
            }
        });
    }

    @ReactMethod
    public void distance(ReadableMap readableMap, final Promise promise) {
        MapmyIndiaDistanceMatrix.Builder mBuilder = MapmyIndiaDistanceMatrix.builder();
        if(readableMap.hasKey("coordinates")) {
            ReadableArray coordinatesArray = readableMap.getArray("coordinates");
            if(coordinatesArray.size() >= 2) {
                for(int i = 0; i < coordinatesArray.size(); i++) {
                    String coordinate = coordinatesArray.getString(i);
                    if (coordinate.contains(",")){
                        String[] location = coordinate.split(",");
                         mBuilder.coordinate(Point.fromLngLat(Double.parseDouble(location[0]), Double.parseDouble(location[1])));
                    }else {
                        mBuilder.coordinate(coordinate);
                    }
                }
            } else {
                promise.reject(REQUIRED_CODE,"Please provide atleast two coordinates");
            }
        } else {
            promise.reject(REQUIRED_CODE,"Please provide coordinates");
            //failureCallback.invoke("Please provide coordinates");
        }
        if(readableMap.hasKey("profile")) {
            mBuilder.profile(readableMap.getString("profile"));
        }
        if(readableMap.hasKey("resource")) {
            mBuilder.profile(readableMap.getString("resource"));
        }
        mBuilder.build().enqueueCall(new Callback<DistanceResponse>() {
            @Override
            public void onResponse(Call<DistanceResponse> call, Response<DistanceResponse> response) {
                if (response.code() == 200) {
                    if (response.body() != null) {
                        DistanceResponse distanceResponse = response.body();
                        promise.resolve(new Gson().toJson(distanceResponse));
                        //successCallback.invoke(response.code(), new Gson().toJson(distanceResponse));
                    } else {
                        //successCallback.invoke(response.code(), null);
                        promise.resolve(null);
                    }
                } else {
                    promise.reject(String.valueOf(response.code()), response.message());
                }
            }

            @Override
            public void onFailure(Call<DistanceResponse> call, Throwable t) {
                //failureCallback.invoke(t.getMessage());
                promise.reject("0",t.getLocalizedMessage());
            }
        });
    }

    @ReactMethod
    public void feedback(ReadableMap readableMap,  final Promise promise) {
        MapmyIndiaFeedback.Builder mBuilder = MapmyIndiaFeedback.builder();
        if(readableMap.hasKey("typedKeyword")) {
            mBuilder.typedKeyword(readableMap.getString("typedKeyword"));
        } else {
            promise.reject(REQUIRED_CODE,"Please provide typed keyword");
        }
        if(readableMap.hasKey("eLoc")) {
            mBuilder.eLoc(readableMap.getString("eLoc"));
        } else {
            promise.reject(REQUIRED_CODE,"Please provide ELoc");
        }
        if(readableMap.hasKey("index")) {
            mBuilder.index(readableMap.getInt("index"));
        } else {
            promise.reject(REQUIRED_CODE,"Please provide index");
        }
        if(readableMap.hasKey("appVersion")) {
            mBuilder.appVersion(readableMap.getString("appVersion"));
        } else {
            promise.reject(REQUIRED_CODE,"Please provide appVersion");
        }
        if(readableMap.hasKey("locationName")) {
            mBuilder.locationName(readableMap.getString("locationName"));
        }else{
            promise.reject(REQUIRED_CODE,"Please provide locationName");
        }
        if(readableMap.hasKey("userName")) {
            mBuilder.userName(readableMap.getString("userName"));
        }else{
            promise.reject(REQUIRED_CODE,"Please provide userName");
        }
        if(readableMap.hasKey("latitude")) {
            mBuilder.latitude(readableMap.getDouble("latitude"));
        }else{
            promise.reject(REQUIRED_CODE,"Please provide latitude");
        }
        if(readableMap.hasKey("longitude")) {
            mBuilder.longitude(readableMap.getDouble("longitude"));
        }else{
            promise.reject(REQUIRED_CODE,"Please provide longitude");
        }
        mBuilder.build().enqueueCall(new Callback<Void>() {
            @Override
            public void onResponse(Call<Void> call, Response<Void> response) {
               if (response.code() == 201){
                   promise.resolve("success");
               }
            }

            @Override
            public void onFailure(Call<Void> call, Throwable t) {
                promise.reject("0",t.getLocalizedMessage());
            }
        });
    }

    @ReactMethod
    public void MapmyIndiaClusterLinkedDevices(ReadableMap readableMap, final Promise promise){

        MapmyIndiaClusterLinkedDevices.Builder mapmyIndiaDeviceBuilder = MapmyIndiaClusterLinkedDevices.builder();

        if(readableMap.hasKey("clusterId") && !readableMap.isNull("clusterId")) {
            mapmyIndiaDeviceBuilder.clusterId(readableMap.getString("clusterId"));
        } else {
            promise.reject(REQUIRED_CODE,"Please provide clusterId");
        }
        if(readableMap.hasKey("sessionType") && !readableMap.isNull("sessionType")) {
            mapmyIndiaDeviceBuilder.sessionType(readableMap.getString("sessionType"));
        } else {
            mapmyIndiaDeviceBuilder.sessionType(SessionCriteria.SESSION_TYPE_GLOBAL);
        }


        MapmyIndiaClusterLinkedDevicesManager.newInstance(mapmyIndiaDeviceBuilder.build()).call(new OnResponseCallback<List<Device>>() {
            @Override
            public void onSuccess(List<Device> devices) {
                promise.resolve(new Gson().toJson(devices));
            }

            @Override
            public void onError(int i, String s) {
                promise.reject(String.valueOf(i),s);
            }
        });
    }


    @ReactMethod
    public void MapmyIndiaDeleteClusterLinkedDevice(ReadableMap readableMap,final  Promise promise){

        MapmyIndiaDeleteClusterLinkedDevice.Builder mBuilder = MapmyIndiaDeleteClusterLinkedDevice.builder();

        if(readableMap.hasKey("linkedDevice") && !readableMap.isNull("linkedDevice")) {
            mBuilder.linkedDevice(readableMap.getString("linkedDevice"));
        } else {
            promise.reject(REQUIRED_CODE,"Please provide linkedDevice");
        }

        if(readableMap.hasKey("clusterId") && !readableMap.isNull("clusterId")) {
            mBuilder.clusterId(readableMap.getString("clusterId"));
        } else {
            promise.reject(REQUIRED_CODE,"Please provide clusterId");
        }
        if(readableMap.hasKey("sessionType") && !readableMap.isNull("sessionType")) {
            mBuilder.sessionType(Objects.requireNonNull(readableMap.getString("sessionType")));
        } else {
            mBuilder.sessionType(SessionCriteria.SESSION_TYPE_GLOBAL);
        }
        MapmyIndiaDeleteClusterLinkedDeviceManager.newInstance(mBuilder.build()).call(new OnResponseCallback<Void>() {
            @Override
            public void onSuccess(Void unused) {
               promise.resolve("success");
            }

            @Override
            public void onError(int i, String s) {
                promise.reject(String.valueOf(i),s);
            }
        });
    }

    @ReactMethod
    public void MapmyIndiaEndSession(ReadableMap readableMap,final  Promise promise){

        MapmyIndiaEndSession.Builder mSessionBuilder = MapmyIndiaEndSession.builder();

        if(readableMap.hasKey("clusterId") && !readableMap.isNull("clusterId")) {
            mSessionBuilder.clusterId(readableMap.getString("clusterId"));
        } else {
            promise.reject(REQUIRED_CODE,"Please provide clusterId");
        }
        if(readableMap.hasKey("sessionType") && !readableMap.isNull("sessionType")) {
            mSessionBuilder.sessionType(Objects.requireNonNull(readableMap.getString("sessionType")));
        } else {
            mSessionBuilder.sessionType(SessionCriteria.SESSION_TYPE_GLOBAL);
        }
        MapmyIndiaEndSessionManager.newInstance(mSessionBuilder.build()).call(new OnResponseCallback<Void>() {
            @Override
            public void onSuccess(Void unused) {
                promise.resolve("success");
            }

            @Override
            public void onError(int i, String s) {
                promise.reject(String.valueOf(i),s);
            }
        });
    }
}