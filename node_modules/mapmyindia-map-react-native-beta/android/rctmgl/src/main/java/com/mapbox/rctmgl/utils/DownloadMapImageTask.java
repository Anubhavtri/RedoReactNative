package com.mapbox.rctmgl.utils;

import android.content.Context;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.os.AsyncTask;
import android.os.Handler;
import android.os.Looper;
import android.util.DisplayMetrics;
import android.util.Log;

import com.facebook.common.logging.FLog;
import com.facebook.common.references.CloseableReference;
import com.facebook.datasource.DataSource;
import com.facebook.datasource.DataSources;
import com.facebook.drawee.backends.pipeline.Fresco;
import com.facebook.imagepipeline.common.RotationOptions;
import com.facebook.imagepipeline.image.CloseableImage;
import com.facebook.imagepipeline.image.CloseableStaticBitmap;
import com.facebook.imagepipeline.request.ImageRequest;
import com.facebook.imagepipeline.request.ImageRequestBuilder;
import com.facebook.react.views.imagehelper.ImageSource;
import com.mapbox.mapboxsdk.maps.MapboxMap;

import java.lang.ref.WeakReference;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;

import javax.annotation.Nullable;

/**
 * Created by nickitaliano on 9/13/17.
 */

public class DownloadMapImageTask {
    public static final String LOG_TAG = DownloadMapImageTask.class.getSimpleName();

    private WeakReference<Context> mContext;
    private WeakReference<MapboxMap> mMap;
    @Nullable
    private OnAllImagesLoaded mCallback;
    private final Object mCallerContext;
    private final Executor executor = Executors.newSingleThreadExecutor(); // change according to your requirements
    private final Handler handler = new Handler(Looper.getMainLooper());

    public DownloadMapImageTask(Context context, MapboxMap map, @Nullable OnAllImagesLoaded callback) {
        mContext = new WeakReference<>(context.getApplicationContext());
        mMap = new WeakReference<>(map);
        mCallback = callback;
        mCallerContext = this;
    }

    public interface OnAllImagesLoaded {
        void onAllImagesLoaded();
    }

    public void execute(final Map.Entry<String, ImageEntry>[] imageEntry) {

        System.out.println("Before Executor");
        executor.execute(new Runnable() {
            @Override
            public void run() {
                System.out.println("Before Callable");
                final List<Map.Entry<String, Bitmap>> images = new LongRunningTask(imageEntry, mCallerContext, mContext.get()).call();
                handler.post(new Runnable() {
                    @Override
                    public void run() {
                        System.out.println("After getting Bitmap");
                        MapboxMap map = mMap.get();
                        if (map != null && images != null && images.size() > 0) {

                            HashMap<String, Bitmap> bitmapImages = new HashMap<>();
                            for (Map.Entry<String, Bitmap> image : images) {
                                bitmapImages.put(image.getKey(), image.getValue());
                            }
                            map.addImages(bitmapImages);

                        }

                        if (mCallback != null) {
                            mCallback.onAllImagesLoaded();
                        }
                    }
                });
            }
        });
    }


}
