package com.reactlibrary;

import android.app.Activity;
import android.content.Intent;
import android.graphics.Color;

import com.facebook.react.bridge.ActivityEventListener;
import com.facebook.react.bridge.Promise;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactMethod;
import com.facebook.react.bridge.ReadableArray;
import com.facebook.react.bridge.ReadableMap;
import com.mapbox.geojson.Point;
import com.mapmyindia.sdk.plugins.places.autocomplete.PlaceAutocomplete;
import com.mapmyindia.sdk.plugins.places.autocomplete.model.PlaceOptions;
import com.mmi.services.api.autosuggest.AutoSuggestCriteria;

import java.util.HashMap;
import java.util.Map;

public class MapmyindiaReactNativePlacePickerModule extends ReactContextBaseJavaModule {

    private final ReactApplicationContext reactContext;
    private Promise promise;

    public MapmyindiaReactNativePlacePickerModule(ReactApplicationContext reactContext) {
        super(reactContext);
        this.reactContext = reactContext;
    }

    @Override
    public void initialize() {
        super.initialize();
        reactContext.addActivityEventListener(mActivityEventListener);
    }

    @Override
    public boolean canOverrideExistingModule() {
        return true;
    }

    @Override
   public Map<String, Object> getConstants() {
   final Map<String, Object> constants = new HashMap<>();
   //PlaceOptions

    //Pods
    constants.put("POD_SUB_LOCALITY_KEY", AutoSuggestCriteria.POD_SUB_LOCALITY);
    constants.put("POD_LOCALITY_KEY",AutoSuggestCriteria.POD_LOCALITY);
    constants.put("POD_CITY_KEY", AutoSuggestCriteria.POD_CITY);
    constants.put("POD_VILLAGE_KEY", AutoSuggestCriteria.POD_VILLAGE);
    constants.put("POD_SUB_DISTRICT_KEY", AutoSuggestCriteria.POD_SUB_DISTRICT);
    constants.put("POD_DISTRICT_KEY", AutoSuggestCriteria.POD_DISTRICT);
    constants.put("POD_STATE_KEY", AutoSuggestCriteria.POD_STATE);
    constants.put("POD_SUB_SUB_LOCALITY_KEY", AutoSuggestCriteria.POD_SUB_SUB_LOCALITY);
    
    //attributionHorizontalAlignment
     constants.put("GRAVITY_LEFT_KEY", PlaceOptions.GRAVITY_LEFT);
     constants.put("GRAVITY_CENTER_KEY",  PlaceOptions.GRAVITY_CENTER); 
     constants.put("GRAVITY_RIGHT_KEY", PlaceOptions.GRAVITY_RIGHT); 

     //attributionVerticalAlignment
      constants.put("GRAVITY_TOP_KEY", PlaceOptions.GRAVITY_TOP); 
      constants.put("GRAVITY_BOTTOM_KEY", PlaceOptions.GRAVITY_BOTTOM); 
   

    //logoSize
    constants.put("SIZE_SMALL_KEY",PlaceOptions.SIZE_SMALL); 
    constants.put("SIZE_MEDIUM_KEY", PlaceOptions.SIZE_MEDIUM); 
    constants.put("SIZE_LARGE_KEY", PlaceOptions.SIZE_LARGE); 
   return constants;
}

    @Override
    public String getName() {
        return "MapmyindiaReactNativePlacePicker";
    }


    private ActivityEventListener mActivityEventListener = new ActivityEventListener() {
        @Override
        public void onActivityResult(Activity activity, int requestCode, int resultCode, Intent data) {
            if(requestCode == 102) {
                if(resultCode == Activity.RESULT_OK) {
                    if(promise != null) {
                        String result=data.getStringExtra("com.mapmyindia.sdk.plugins.places.eLocation");
                        promise.resolve(result);
                    }
                } else {
                    promise.reject("Cancel", "Close");

                }
            }

        }

        @Override
        public void onNewIntent(Intent intent) {

        }


    };

    @ReactMethod
    public void openPlaceWidget(final ReadableMap map,Promise promise) {

        this.promise = promise;
        if(getCurrentActivity() == null) {
            promise.reject("Error", "You are not directly attached with activity");
            return;
        }

        PlaceOptions.Builder placeOptionsBuilder=PlaceOptions.builder();
        if (map.hasKey("location")){
            ReadableArray location=map.getArray("location");
            //val latLong: List<String> = searchMap.getString("location")!!.split(",")
            if (location!=null&&location.size()==2){
                double latitude = location.getDouble(1);//latLong[1].toDouble()
                double longitude = location.getDouble(0);//latLong[0].toDouble()
                placeOptionsBuilder.location(Point.fromLngLat(longitude, latitude));
            }
            /*//String[] latLong =  map.getString("location").split(",");
            double latitude = Double.parseDouble(latLong[1]);
            double longitude = Double.parseDouble(latLong[0]);
            placeOptionsBuilder.location(Point.fromLngLat(longitude,latitude));*/
        }
        if (map.hasKey("historyCount")){
            int historyCount=map.getInt("historyCount");
            placeOptionsBuilder.historyCount(historyCount);
        }
        if (map.hasKey("zoom")){
            double zoom=map.getDouble("zoom");
            placeOptionsBuilder.zoom(zoom);
        }
        if (map.hasKey("saveHistory")){
            boolean saveHistory=map.getBoolean("saveHistory");
            placeOptionsBuilder.saveHistory(saveHistory);
        }
        if (map.hasKey("pod")){
            String pod=map.getString("pod");
            placeOptionsBuilder.pod(pod);
        }
        if (map.hasKey("backgroundColor")){
            int backgroundColor=Color.parseColor(map.getString("backgroundColor"));
            placeOptionsBuilder.backgroundColor(backgroundColor);
        }
        if (map.hasKey("tokenizeAddress")){
            boolean tokenizeAddress=map.getBoolean("tokenizeAddress");
            if (tokenizeAddress)
             placeOptionsBuilder.tokenizeAddress(true);
        }
        if (map.hasKey("toolbarColor")){
            int toolbarColor=Color.parseColor(map.getString("toolbarColor"));
            placeOptionsBuilder.toolbarColor(toolbarColor);
        }
        if (map.hasKey("hint")){
            String hint=map.getString("hint");
            placeOptionsBuilder.hint(hint);
        }
        if (map.hasKey("filter")){
            String filter=map.getString("filter");
            placeOptionsBuilder.filter(filter);
        }

        if (map.hasKey("attributionVerticalAlignment")) {
            int attributionVerticalAlignment = map.getInt("attributionVerticalAlignment");
            placeOptionsBuilder.attributionHorizontalAlignment(attributionVerticalAlignment);
        }
        if (map.hasKey("attributionHorizontalAlignment")) {
            int attributionHorizontalAlignment = map.getInt("attributionHorizontalAlignment");
            placeOptionsBuilder.attributionVerticalAlignment(attributionHorizontalAlignment);
        }
        if (map.hasKey("logoSize")) {
            int logoSize = map.getInt("logoSize");
            placeOptionsBuilder.logoSize(logoSize);
        }
        Intent intent = new PlaceAutocomplete.IntentBuilder()
                .placeOptions(placeOptionsBuilder.build())
                .build(getCurrentActivity());
        getCurrentActivity().startActivityForResult(intent, 102);
    }
   
}
