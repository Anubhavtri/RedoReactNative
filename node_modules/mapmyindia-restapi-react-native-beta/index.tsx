/*
 *  index.js (Entry File)
 *  Ceated by Anuj Singh on 01/03/2019.
 *  Copyright Â© 2019 CE INFO Systems Pvt. Ltd. All rights reserved.
*/
import { NativeModules, Platform } from 'react-native';

var RestApiNative = Platform.OS === 'android' ? NativeModules.RNRestapiModule : NativeModules.RNRestapi;
var keys = false;
var clientId = false;
var clientSecret = false;


interface GeoCodeProps  {
    address:string,
    itemCount?:number,
    podFilter?:string,
    bias?:number,
    bound?:string

}

interface AutoSuggestProps {

    query:string,
    zoom?:number,
    location?:string,
    pod?:string,
    filter?:string,
    tokenizeAddress?:boolean

}

interface RevGeoCodeParms {
    lat:number,
    lng:number

}

interface NearbyProps {

    keywords:string,
    refLocation :string,
    page?:number,
    sort?:string,
    radius?:number,
    bounds?:string,
    filter?:string

}

interface PlaceDetailsProps {
    eloc:string
}

interface DistanceMatrixProps {
    source:string,
    destinations:string,
    rtype:number,
    region:string,
    profile:string

}

interface RoutingAdvProps {
    source:string ,
    destination:string
     geometries?:string,
                 steps? :boolean, 
                 profile?:string,
                 exclude ?:string
                 rtype ?:number,
                 region?:string,
                 overview?:string
                 bearings? :number,
                 alternatives?: number,
                 radiuses ?:string
}

var Mapmyindia = {
    setRestApiKey: function(RestApiKey){
        keys = (RestApiKey) ? true : false;
        RestApiNative.setRestApiKey(RestApiKey);
    },
    setClientId: function(client_id){
        clientId = (client_id) ? true : false;
        RestApiNative.setClientId(client_id);
    },
    setClientSecret: function(client_secret){
        clientSecret = (client_secret) ? true : false;
        RestApiNative.setClientSecret(client_secret);
    },
    placeDetails: function(params:PlaceDetailsProps,success){
        if(keys){
            if(params.eloc){
                let eloc = params.eloc;
                RestApiNative.placeDetails(eloc,success);
            }else{
                error('Eloc/PlaceId required');
                return false;
            }
        }else
        {
            error('Set RestApiKey');
            return false;
        }
    },

    rev_geocode: function(params:RevGeoCodeParms,success){
        if(keys){
            if(params.lat && params.lng){
                let lat = params.lat;
                let lng = params.lng;
                RestApiNative.rev_geocode(lat.toString(),lng.toString(),success);
            }else{
                error('Parameter missing');
                return false;
            }
        }else {
            error('Set RestApiKey');
            return false;
        }
    },
    atlas_auto: function(params:AutoSuggestProps,success){
        if(clientId && clientSecret){
            if(params.query){
                let query = params.query;
                RestApiNative.atlas_auto(query,params,success);
            }else{
                error('search query is missing');
                return false;
            }
        }else{
            error('Set ClientId and Secret');
            return false;
        }
    },
    atlas_nearby: function(params:NearbyProps,success){
        if(clientId && clientSecret){
            if(params.keywords && params.refLocation){
                console.log(params);
                
                RestApiNative.atlas_nearby(params,success);
            }else{
                error('Parameter missing');
                return false;
            }
        }else{
            error('Set ClientId and Secret');
            return false;
        }
    },

    atlas_geocode: (params:GeoCodeProps, success) => {
        console.log(params)
        if (clientId && clientSecret) {
            if (params.address) {
                let addr = params.address;
                RestApiNative.atlas_geocode(addr, params, success);
            } else {
                error('address missing');
                return false;
            }
        } else {
            error('Set ClientId and Secret');
            return false;
        }
    },
    

    place_details: function(params, success) {
        if(clientId && clientSecret){
            if(params.eLoc){
                let query = params.eLoc;
                RestApiNative.place_details(query,success);
            }else{
                error('ELoc is missing');
                return false;
            }
        }else{
            error('Set ClientId and Secret');
            return false;
        }
    },

    distance_matrix: function(params:DistanceMatrixProps,success){
        if(keys){
            if(params.source && params.destinations){
                let source = params.source;
                let sourcelist = source.split(";");
                let sources = "";
                if(sourcelist.length == 1) {
                    sources = "0";
                } else {
                    let size = sourcelist.length;
                    var i:number;
                    for(i=0;i<size;i++) {
                        if(i == size -1) {
                            sources=sources + i;
                        } else {
                            sources = sources + i +";";
                        }
                    }
                }

                let destination = params.destinations;
                let destinationList = destination.split(";");
                let destinations = "";
                if(sourcelist.length == 1) {
                    destinations = "all";
                } else {
                    let size = destinationList.length;
                    var i: number;
                    for(i=sourcelist.length;i<(sourcelist.length + size);i++) {
                        if(i == (sourcelist.length + size) -1) {
                            destinations=destinations + i;
                        } else {
                            destinations = destinations + i +";";
                        }
                    }
                }
                let rtype = (params.rtype) ? params.rtype : '0';
                let region = (params.region) ? params.region : 'ind';
                let profile=(params.profile)?params.profile:'driving';
                RestApiNative.distance_matrix(source, destination,profile,region,rtype,sources,destinations,success);
            }else{
                error('Parameter missing');
                return false;
            }
        }else{
            error('Set RestApiKey');
            return false;
        }
    },
    distance_matrix_eta: function(params:DistanceMatrixProps,success){
            if(keys){
                if(params.source && params.destinations){
                    let rtype = (params.rtype) ? params.rtype : '0';
                    let region = (params.region) ? params.region : 'ind';
                    let source = params.source;
                    let sourcelist = source.split(";");
                    let sources = "";
                    if(sourcelist.length == 1) {
                        sources = "0";
                    } else {
                        let size = sourcelist.length;
                        var i:number;
                        for(i=0;i<size;i++) {
                            if(i == size -1) {
                                sources=sources + i;
                            } else {
                                sources = sources + i +";";
                            }
                        }
                    }

                    let destination = params.destinations;
                    let destinationList = destination.split(";");
                    let destinations = "";
                    if(sourcelist.length == 1) {
                        destinations = "all";
                    } else {
                        let size = destinationList.length;
                        var i: number;
                        for(i=sourcelist.length;i<(sourcelist.length + size);i++) {
                            if(i == (sourcelist.length + size) -1) {
                                destinations=destinations + i;
                            } else {
                                destinations = destinations + i +";";
                            }
                        }
                    }
                    let profile=(params.profile)?params.profile:'driving';
                    RestApiNative.distance_matrix_eta(source,destination,profile,region,rtype,sources,destinations,success);
                }else{
                    error('Parameter missing');
                    return false;
                }
            }else{
                error('Set RestApiKey');
                return false;
            }
        },
  
    route_adv: function(params:RoutingAdvProps,success){
        if(keys){
            if(params.source && params.destination){
                let geometries = (params.geometries) ? params.geometries : 'polyline';
                let steps = (params.steps) ? params.steps : 'false';
                let profile=(params.profile)?params.profile :'driving';
                let exclude = (params.exclude) ? params.exclude : '';
                let rtype = (params.rtype) ? params.rtype : '0';
                let region = (params.region) ? params.region : 'ind';
                let overview = (params.overview) ? params.overview : 'simplified';
                let bearings = (params.bearings) ? params.bearings : '';
                let alternatives = (params.alternatives) ? params.alternatives : '';
                let radiuses = (params.radiuses) ? params.radiuses : '';
                RestApiNative.route_adv(params.source,params.destination,profile, geometries, steps, exclude, rtype, region, overview, bearings, alternatives, radiuses,success);
            }else{
                error('Parameter missing');
                return false;
            }
        }else{
            error('Set RestApiKey');
            return false;
        }
    },
    route_eta: function(params:RoutingAdvProps,success){
        if(keys){
            if(params.source && params.destination){
                let geometries = (params.geometries) ? params.geometries : 'polyline';
                let steps = (params.steps) ? params.steps : 'false';
                let exclude = (params.exclude) ? params.exclude : '';
                let profile=(params.profile)?params.profile:'driving';
                let rtype = (params.rtype) ? params.rtype : '0';
                let region = (params.region) ? params.region : 'ind';
                let overview = (params.overview) ? params.overview : 'simplified';
                let bearings = (params.bearings) ? params.bearings : '';
                let alternatives = (params.alternatives) ? params.alternatives : '';
                let radiuses = (params.radiuses) ? params.radiuses : '';
                RestApiNative.route_eta(params.source,params.destination,profile,geometries, steps, exclude, rtype, region, overview, bearings, alternatives, radiuses,success);
            }else{
                error('Parameter missing');
                return false;
            }
        }else{
            error('Set RestApiKey');
            return false;
        }
    }
};

function error(message){
    console.log(message);
    alert(message);
    return false;
}

export default Mapmyindia;
