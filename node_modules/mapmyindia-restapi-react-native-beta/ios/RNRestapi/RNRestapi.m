//
//  RNRestapi.m
//  Methods
//
//  Created by Anuj Singh on 01/03/2019.
//  Copyright Â© 2019 CE INFO Systems Pvt. Ltd. All rights reserved.
//
#import "RNRestapi.h"
#import <React/RCTLog.h>
#import "RCTConvert.h"

@implementation RNRestapi

NSString *BASE_REQ_URL = @"https://apis.mapmyindia.com/advancedmaps/v1";
NSString *OUTPOST_URL = @"https://outpost.mapmyindia.com/api/security/oauth/token";
NSString *EXPLORE_REQ_URL = @"https://explore.mapmyindia.com/apis/O2O/entity/";
NSString *ATLAS_URL = @"https://atlas.mapmyindia.com/api/places";
NSString *oauth2_token_type = @"bearer";
NSDictionary* jsonResponse;
int current_time;
int access_token_validity;
NSString *restApiKey;
NSString *ClientId;
NSString *ClientSecret;
int accessTokenRetryAttempts = 0;
RCT_EXPORT_MODULE();

RCT_EXPORT_METHOD(placeDetails:(NSString *)placeId callback:(RCTResponseSenderBlock)callback){
 @try{
    NSString *final_url = [NSString stringWithFormat:@"%@/%@/place_detail?place_id=%@", BASE_REQ_URL,restApiKey,placeId];
    [self getHttp: final_url :callback];
 }
 @catch(NSException *exception){
    callback(@[exception.reason]);
 }
}

RCT_EXPORT_METHOD(atlas_geocode:(NSString *)addr params:(NSDictionary *)params callback:(RCTResponseSenderBlock)callback){
       NSString *GEOCODE_BASE = [NSString stringWithFormat:@"%@/geocode", ATLAS_URL];
       NSURLComponents *components = [NSURLComponents componentsWithString:GEOCODE_BASE];
       NSMutableArray *queryItems = [NSMutableArray array];
    for (NSString *key in params) {
        NSString *currentValue  =[NSString stringWithFormat:@"%@", [params valueForKey:key]];
        [queryItems addObject:[NSURLQueryItem queryItemWithName:key value:currentValue]];
    }
    components.queryItems = queryItems;
    
 @try{
    [self setTime];
     NSURL *url = components.URL;
     NSString *final_url=url.absoluteString;
    //NSString *final_url = [NSString stringWithFormat:@"%@/geocode?address=%@&itemCount=%@",ATLAS_URL,addr,itemCount];
    [self postHttp: final_url :callback];
 }
 @catch(NSException *exception){
    callback(@[exception.reason]);
 }
}

RCT_EXPORT_METHOD(place_details:(NSString *)eLoc callback:(RCTResponseSenderBlock)callback) {
    @try {
        NSString *PLACEDETAIL_BASE =[NSString stringWithFormat:@"%@%@",EXPLORE_REQ_URL, eLoc];

        [self postHttp:PLACEDETAIL_BASE :callback];
    } @catch (NSException *exception) {
        callback(@[exception.reason]);
    }

}


RCT_EXPORT_METHOD(atlas_auto:(NSString *)query params:(NSDictionary *)params callback:(RCTResponseSenderBlock)callback){
    
    NSString *GEOCODE_BASE = [NSString stringWithFormat:@"%@/search/json", ATLAS_URL];
    NSURLComponents *components = [NSURLComponents componentsWithString:GEOCODE_BASE];
    NSMutableArray *queryItems = [NSMutableArray array];
   for (NSString *key in params) {
     NSString *currentValue  =[NSString stringWithFormat:@"%@", [params valueForKey:key]];
     if ([key isEqualToString:@"tokenizeAddress"]&&[currentValue isEqualToString:@"0"]) {
         continue;
     }
     [queryItems addObject:[NSURLQueryItem queryItemWithName:key value:currentValue]];
 }
 components.queryItems = queryItems;
    
 @try{
    [self setTime];
     NSURL *url = components.URL;
     NSString *final_url=url.absoluteString;
      
    //NSString *final_url = [NSString stringWithFormat:@"%@/search/json?query=%@", ATLAS_URL, query];
    [self postHttp: final_url :callback];
 }
 @catch(NSException *exception){
    callback(@[exception.reason]);
 }
}



RCT_EXPORT_METHOD(atlas_nearby:(NSDictionary *)params callback:(RCTResponseSenderBlock)callback){
 
    NSString *GEOCODE_BASE = [NSString stringWithFormat:@"%@/nearby/json", ATLAS_URL];
    NSURLComponents *components = [NSURLComponents componentsWithString:GEOCODE_BASE];
    NSMutableArray *queryItems = [NSMutableArray array];
 for (NSString *key in params) {
     NSString *currentValue  =[NSString stringWithFormat:@"%@", [params valueForKey:key]];
     [queryItems addObject:[NSURLQueryItem queryItemWithName:key value:currentValue]];
 }
 components.queryItems = queryItems;
    
    
    @try{
    [self setTime];
        NSURL *url = components.URL;
        NSString *final_url=url.absoluteString;
       
   // NSString *final_url = [NSString stringWithFormat:@"%@/nearby/json?keywords=%@&refLocation=%@", ATLAS_URL, keyword, //refLocation];
    [self postHttp: final_url :callback];
 }
 @catch(NSException *exception){
    callback(@[exception.reason]);
 }
}





RCT_EXPORT_METHOD(rev_geocode:(NSString *)lat lng:(NSString *)lng callback:(RCTResponseSenderBlock)callback){
 @try{
    NSString *final_url = [NSString stringWithFormat:@"%@/%@/rev_geocode?lat=%@&lng=%@", BASE_REQ_URL,restApiKey, lat, lng];
    
    [self getHttp: final_url :callback];
 }
 @catch(NSException *exception){
    callback(@[exception.reason]);
 }
}




RCT_EXPORT_METHOD(route_adv:(NSString *)start destination:(NSString *)destination profile:(NSString *)profile geometries:(NSString *)geometries steps:(NSString *)steps exclude:(NSString *)exclude rtype:(NSString *)rtype region:(NSString *)region overview:(NSString *)overview bearings:(NSString *)bearings alternatives:(NSString *)alternatives radiuses:(NSString *)radiuses callback:(RCTResponseSenderBlock)callback){
 @try{
    NSString *final_url = [NSString stringWithFormat:@"%@/%@/route_adv/%@/%@;%@?steps=%@&geometries=%@&exclude=%@&rtype=%@&region=%@&overview=%@&bearings=%@&alternatives=%@&radiuses=%@", BASE_REQ_URL,restApiKey, profile,start,destination, steps,geometries,exclude,rtype,region,overview,bearings,alternatives,radiuses];
    
    [self getHttp: final_url :callback];
 }
 @catch(NSException *exception){
    callback(@[exception.reason]);
 }
}

RCT_EXPORT_METHOD(route_eta:(NSString *)start destination:(NSString *)destination profile:(NSString *)profile geometries:(NSString *)geometries steps:(NSString *)steps exclude:(NSString *)exclude rtype:(NSString *)rtype region:(NSString *)region overview:(NSString *)overview bearings:(NSString *)bearings alternatives:(NSString *)alternatives radiuses:(NSString *)radiuses callback:(RCTResponseSenderBlock)callback){
 @try{
    NSString *final_url = [NSString stringWithFormat:@"%@/%@/route_eta/%@/%@;%@?steps=%@&geometries=%@&exclude=%@&rtype=%@&region=%@&overview=%@&bearings=%@&alternatives=%@&radiuses=%@", BASE_REQ_URL,restApiKey, profile,start,destination, steps,geometries,exclude,rtype,region,overview,bearings,alternatives,radiuses];
      
     [self getHttp: final_url :callback];
 }
 @catch(NSException *exception){
    callback(@[exception.reason]);
 }
}

RCT_EXPORT_METHOD(distance_matrix:(NSString *)start destination:(NSString *)destination profile:(NSString *)profile region:(NSString *)region rtype:(NSString *)rtype sources:(NSString *)sources destinations:(NSString *)destinations callback:(RCTResponseSenderBlock)callback){
 @try{
    NSString *final_url = [NSString stringWithFormat:@"%@/%@/distance_matrix/%@/%@;%@?rtype=%@&region=%@&sources=%@&destinations=%@", BASE_REQ_URL,restApiKey, profile,start,destination,rtype,region,sources,destinations];
    
    [self getHttp: final_url :callback];
 }
 @catch(NSException *exception){
    callback(@[exception.reason]);
 }
}

RCT_EXPORT_METHOD(distance_matrix_eta:(NSString *)start destination:(NSString *)destination profile:(NSString *)profile region:(NSString *)region rtype:(NSString *)rtype sources:(NSString *)sources destinations:(NSString *)destinations  callback:(RCTResponseSenderBlock)callback){
 @try{
    NSString *final_url = [NSString stringWithFormat:@"%@/%@/distance_matrix_eta/%@/%@;%@?rtype=%@&region=%@&sources=%@&destinations=%@", BASE_REQ_URL,restApiKey, profile,start,destination,rtype,region,sources,destinations];
  
    [self getHttp: final_url :callback];
 }
 @catch(NSException *exception){
    callback(@[exception.reason]);
 }
}

RCT_EXPORT_METHOD(setRestApiKey:(NSString *)key){
    restApiKey = key;
}

RCT_EXPORT_METHOD(setClientId:(NSString *)client_id){
    ClientId = client_id;
}

RCT_EXPORT_METHOD(setClientSecret:(NSString *)client_secret){
    ClientSecret = client_secret;
}

- (void) getHttp:(NSString *)url :(RCTResponseSenderBlock)result {
      NSMutableURLRequest *request = [[NSMutableURLRequest alloc] init];
      [request setURL:[NSURL URLWithString: url]];
      [request setHTTPMethod:@"GET"];

      NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];
      [[session dataTaskWithRequest:request completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {

      NSDictionary *json = [NSJSONSerialization JSONObjectWithData:data
                                                           options:kNilOptions
                                                             error:&error];
      if(!error){
        jsonResponse = json;
      } else {
        jsonResponse = [NSDictionary dictionaryWithObjectsAndKeys:
                            @"400", @"status",
                            @"something went wrong/key is wrong/parameters are not valid", @"message", nil];
      }
    result(@[jsonResponse]);
  }] resume];
}

- (void)setOAuth2AccessToken:(nullable void (^)(void))completion {
    NSMutableURLRequest *urlRequest = [[NSMutableURLRequest alloc] initWithURL:[NSURL URLWithString: OUTPOST_URL]];
    [urlRequest setHTTPMethod:@"POST"];
    NSString *request =[NSString stringWithFormat:@"grant_type=client_credentials&client_id=%@&client_secret=%@", ClientId, ClientSecret];
    NSData *req_data = [request dataUsingEncoding:NSUTF8StringEncoding];
    [urlRequest setHTTPBody:req_data];
    NSURLSession *session = [NSURLSession sharedSession];
    NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:urlRequest completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
        NSError *parseError = nil;
        NSDictionary *responseObj = [NSJSONSerialization JSONObjectWithData:data options:0 error:&parseError];
        if([responseObj[@"error"] isEqualToString: @"invalid_client"]){
            NSLog(@"http code");
        } else {
            NSDate *now = [NSDate date];
            NSTimeInterval nowEpochSeconds = [now timeIntervalSince1970];
            current_time = (int) nowEpochSeconds;
            int expires_in_token =  (int)responseObj[@"expires_in"];
            int valid_till = (expires_in_token/1000) + (current_time);
            [[NSUserDefaults standardUserDefaults] setObject:responseObj[@"access_token"] forKey:@"access_token"];
            [[NSUserDefaults standardUserDefaults] setObject:[NSNumber numberWithInt:valid_till] forKey:@"access_token_validity"];
            [[NSUserDefaults standardUserDefaults] synchronize];
        }
        if (completion)
        {
            completion();
        }
        return;
    }];
    [dataTask resume];
}

- (void) postHttp:(NSString *)url :(RCTResponseSenderBlock)result {
    /*
     //Check token validity
     NSDate *now = [NSDate date];
     NSTimeInterval nowEpochSeconds = [now timeIntervalSince1970];
     current_time = (int) nowEpochSeconds;
     int validity = [[[NSUserDefaults standardUserDefaults] objectForKey:@"access_token_validity"] intValue];
     NSLog(@"%d", validity);
     if (validity <= current_time) {
     [self setOAuth2AccessToken];
     }
     */
    //Check token availability
    NSString * accessToken = [[NSUserDefaults standardUserDefaults] stringForKey:@"access_token"];
    if ([accessToken length] > 0) {
        NSMutableURLRequest *request = [[NSMutableURLRequest alloc] init];
        [request setURL:[NSURL URLWithString: url]];
        [request setHTTPMethod:@"GET"];
        
        [request setValue: [NSString stringWithFormat:@"%@ %@", oauth2_token_type, accessToken]  forHTTPHeaderField:@"Authorization"];
        
        NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];
        [[session dataTaskWithRequest:request completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
            if (error) {
                accessTokenRetryAttempts = 0;
                jsonResponse = [NSDictionary dictionaryWithObjectsAndKeys:
                                [NSNumber numberWithInteger:error.code], @"status",
                                error.localizedDescription, @"message", nil];
                result(@[jsonResponse]);
            } else if(data){
                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                if (httpResponse.statusCode == 200 || httpResponse.statusCode == 201) {
                    accessTokenRetryAttempts = 0;
                    NSDictionary *responseObj = [NSJSONSerialization JSONObjectWithData:data
                                                                                options:kNilOptions
                                                                                  error:&error];
                    jsonResponse = responseObj;
                    result(@[jsonResponse]);
                } else if (httpResponse.statusCode == 401) {
                    // oAuth Retry Attempts
                    if (accessTokenRetryAttempts > 2) {
                        accessTokenRetryAttempts = 0;
                        jsonResponse = [NSDictionary dictionaryWithObjectsAndKeys:
                                        [NSNumber numberWithInteger:error.code], @"status",
                                        error.localizedDescription, @"message", nil];
                        result(@[jsonResponse]);
                    } else {
                        accessTokenRetryAttempts = accessTokenRetryAttempts + 1;
                        __weak typeof(self) weakSelf = self;
                        [self setOAuth2AccessToken:^{
                            [weakSelf postHttp: url :result];
                        }];
                    }
                } else {
                    accessTokenRetryAttempts = 0;
                    jsonResponse = [NSDictionary dictionaryWithObjectsAndKeys:
                                    [NSNumber numberWithInteger: httpResponse.statusCode], @"status",
                                    @"something went wrong", @"message", nil];
                    result(@[jsonResponse]);
                }
            } else {
                accessTokenRetryAttempts = 0;
                jsonResponse = [NSDictionary dictionaryWithObjectsAndKeys:
                                @"400", @"status",
                                @"something went wrong", @"message", nil];
                result(@[jsonResponse]);
            }
        }] resume];
    } else {
        __weak typeof(self) weakSelf = self;
        [self setOAuth2AccessToken:^{
            [weakSelf postHttp: url :result];
        }];
    }
}

- (void)setTime
{
    NSDate *now = [NSDate date];
    NSTimeInterval nowEpochSeconds = [now timeIntervalSince1970];
    current_time = (int) nowEpochSeconds;
}

@end
